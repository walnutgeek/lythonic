{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Lythonic","text":"<p>Light-weight pythonic SQLite integration with Pydantic.</p> <p>Lythonic provides a simple ORM-like interface for SQLite databases using Pydantic models to define the schema. It supports automatic DDL generation, CRUD operations, type mapping, and multi-tenant access patterns.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pydantic-based schema - Define tables as Pydantic models</li> <li>Automatic DDL - Generate CREATE TABLE statements from models</li> <li>Type mapping - Automatic conversion between Python and SQLite types</li> <li>CRUD operations - Insert, select, update with filtering</li> <li>Multi-tenant support - Built-in user-scoped data access patterns</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install lythonic\n</code></pre> <p>Or with uv:</p> <pre><code>uv add lythonic\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pydantic import Field\nfrom lythonic.state import DbModel, Schema, open_sqlite_db\n\nclass Author(DbModel[\"Author\"]):\n    author_id: int = Field(default=-1, description=\"(PK)\")\n    name: str\n\nclass Book(DbModel[\"Book\"]):\n    book_id: int = Field(default=-1, description=\"(PK)\")\n    author_id: int = Field(description=\"(FK:Author.author_id)\")\n    title: str\n    year: int | None = None\n\nSCHEMA = Schema([Author, Book])\nSCHEMA.create_schema(\"books.db\")\n\nwith open_sqlite_db(\"books.db\") as conn:\n    author = Author(name=\"Jane Austen\")\n    author.save(conn)\n\n    book = Book(author_id=author.author_id, title=\"Pride and Prejudice\", year=1813)\n    book.save(conn)\n\n    books = Book.select(conn, author_id=author.author_id)\n    conn.commit()\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>Tutorials - Step-by-step guides</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing Lythonic and creating your first database schema.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install lythonic\n</code></pre> <p>Or with uv:</p> <pre><code>uv add lythonic\n</code></pre>"},{"location":"getting-started/#define-your-first-model","title":"Define Your First Model","text":"<p>Create a Python file with your schema definition:</p> <pre><code>from pydantic import Field\nfrom lythonic.state import DbModel, Schema\n\nclass Task(DbModel[\"Task\"]):\n    task_id: int = Field(default=-1, description=\"(PK)\")\n    title: str = Field(description=\"Task title\")\n    completed: bool = Field(default=False)\n\nSCHEMA = Schema([Task])\n</code></pre> <p>Key points:</p> <ul> <li>Inherit from <code>DbModel[\"YourClassName\"]</code> (the string must match the class name)</li> <li>Mark primary keys with <code>(PK)</code> in the field description</li> <li>Use <code>default=-1</code> for auto-increment primary keys</li> </ul>"},{"location":"getting-started/#create-the-database","title":"Create the Database","text":"<pre><code>from pathlib import Path\n\nSCHEMA.create_schema(Path(\"tasks.db\"))\n</code></pre> <p>This generates and executes:</p> <pre><code>CREATE TABLE Task (\n    task_id INTEGER PRIMARY KEY,\n    title TEXT NOT NULL,\n    completed INTEGER NOT NULL\n)\n</code></pre>"},{"location":"getting-started/#insert-and-query-data","title":"Insert and Query Data","text":"<pre><code>from lythonic.state import open_sqlite_db\n\nwith open_sqlite_db(\"tasks.db\") as conn:\n    # Create a task\n    task = Task(title=\"Learn Lythonic\")\n    task.save(conn)  # Inserts and sets task_id\n\n    print(f\"Created task with id: {task.task_id}\")\n\n    # Query all tasks\n    all_tasks = Task.select(conn)\n\n    # Query with filter\n    incomplete = Task.select(conn, completed=False)\n\n    # Load by ID\n    loaded = Task.load_by_id(conn, task.task_id)\n\n    conn.commit()\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Your First Schema Tutorial - Deeper dive into schema definition</li> <li>CRUD Operations - All database operations explained</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"how-to/define-schema/","title":"How to Define a Schema","text":""},{"location":"how-to/define-schema/#basic-model","title":"Basic Model","text":"<pre><code>from pydantic import Field\nfrom lythonic.state import DbModel\n\nclass MyModel(DbModel[\"MyModel\"]):\n    id: int = Field(default=-1, description=\"(PK)\")\n    name: str\n</code></pre>"},{"location":"how-to/define-schema/#primary-key","title":"Primary Key","text":"<p>Add <code>(PK)</code> to field description, use <code>default=-1</code> for auto-increment:</p> <pre><code>user_id: int = Field(default=-1, description=\"(PK)\")\n</code></pre>"},{"location":"how-to/define-schema/#foreign-key","title":"Foreign Key","text":"<p>Add <code>(FK:Table.field)</code> to field description:</p> <pre><code>author_id: int = Field(description=\"(FK:Author.author_id)\")\n</code></pre>"},{"location":"how-to/define-schema/#nullable-fields","title":"Nullable Fields","text":"<p>Use union with <code>None</code>:</p> <pre><code>email: str | None = Field(default=None)\n</code></pre>"},{"location":"how-to/define-schema/#constrained-values","title":"Constrained Values","text":"<p>Use <code>Literal</code> for enum-like constraints:</p> <pre><code>from typing import Literal\n\nstatus: Literal[\"draft\", \"published\", \"archived\"]\n</code></pre>"},{"location":"how-to/define-schema/#complex-types","title":"Complex Types","text":"<p>Nested Pydantic models are stored as JSON:</p> <pre><code>from lythonic.types import JsonBase\n\nclass Settings(JsonBase):\n    theme: str = \"light\"\n    notifications: bool = True\n\nclass User(DbModel[\"User\"]):\n    user_id: int = Field(default=-1, description=\"(PK)\")\n    settings: Settings = Field(default_factory=Settings)\n</code></pre>"},{"location":"how-to/define-schema/#register-schema","title":"Register Schema","text":"<pre><code>from lythonic.state import Schema\n\nSCHEMA = Schema([Author, Book, Review])\nSCHEMA.create_schema(Path(\"library.db\"))\n</code></pre> <p>List tables in dependency order (referenced tables first).</p>"},{"location":"how-to/multi-tenant/","title":"How to Build Multi-Tenant Apps","text":"<p>Use <code>UserOwned</code> base class for automatic user scoping.</p>"},{"location":"how-to/multi-tenant/#define-user-owned-models","title":"Define User-Owned Models","text":"<pre><code>from lythonic.state.user import User, UserOwned, UserContext\nfrom pydantic import Field\n\nclass Project(UserOwned[\"Project\"]):\n    project_id: int = Field(default=-1, description=\"(PK)\")\n    name: str\n</code></pre> <p><code>UserOwned</code> automatically adds:</p> <pre><code>user_id: int = Field(description=\"(FK:User.user_id)\")\n</code></pre>"},{"location":"how-to/multi-tenant/#create-user-and-context","title":"Create User and Context","text":"<pre><code>from lythonic.state.user import User, UserInfo, UserContext\n\nuser = User(info=UserInfo())\nuser.save(conn)\n\nctx = UserContext(user=user)\n</code></pre>"},{"location":"how-to/multi-tenant/#save-with-context","title":"Save with Context","text":"<pre><code>project = Project(name=\"My Project\")\nproject.save_with_ctx(ctx, conn)  # Sets user_id automatically\n</code></pre>"},{"location":"how-to/multi-tenant/#query-with-context","title":"Query with Context","text":"<p>All queries require context and are scoped to that user:</p> <pre><code># Only returns projects for ctx.user\nprojects = Project.select(conn, user_ctx=ctx)\n\n# Load by ID (returns None if wrong user)\nproject = Project.load_by_id_with_ctx(conn, ctx, project_id=42)\n</code></pre>"},{"location":"how-to/multi-tenant/#schema-setup","title":"Schema Setup","text":"<p>Include <code>User</code> table first:</p> <pre><code>from lythonic.state import Schema\nfrom lythonic.state.user import User\n\nSCHEMA = Schema([User, Project, Task])\n</code></pre>"},{"location":"how-to/multi-tenant/#access-control","title":"Access Control","text":"<p><code>UserOwned</code> prevents accessing other users' data:</p> <ul> <li><code>save_with_ctx()</code> raises error if updating another user's record</li> <li><code>select()</code> automatically filters by <code>user_id</code></li> <li><code>load_by_id_with_ctx()</code> returns <code>None</code> for other users' records</li> </ul>"},{"location":"reference/compose-cli/","title":"lythonic.compose.cli","text":"<p>Build hierarchical command-line interfaces from type-annotated functions.</p> <p>CLI: Build hierarchical command-line interfaces from type-annotated functions.</p> <p>This module provides a declarative way to build CLI applications where commands are organized in a tree structure. Arguments and options are automatically derived from function signatures and Pydantic models.</p>"},{"location":"reference/compose-cli/#lythonic.compose.cli--quick-start","title":"Quick Start","text":"<pre><code>from pydantic import BaseModel, Field\nfrom lythonic.compose.cli import ActionTree, Main, RunContext\n\n# 1. Create the root action tree\nmain = ActionTree(Main)\n\n# 2. Define a subcommand group using a BaseModel\nclass Server(BaseModel):\n    '''Server management commands'''\n    port: int = Field(default=8080, description=\"Port to listen on\")\n\nserver = main.actions.add(Server)\n\n# 3. Add actions to the group using the @wrap decorator\n@server.actions.wrap\ndef start(ctx: RunContext):\n    '''Start the server'''\n    config = ctx.path.get('/server')  # Access parent action's parsed values\n    ctx.print(f\"Starting on port {config.port}\")\n\n@server.actions.wrap\ndef stop():\n    '''Stop the server'''\n    print(\"Stopping server\")\n\n# 4. Run the CLI\nif __name__ == \"__main__\":\n    import sys\n    result = main.run_args(sys.argv)\n    sys.exit(0 if result.success else 1)\n</code></pre> <p>Usage: <code>mycli server start</code> or <code>mycli server --port=9000 start</code></p>"},{"location":"reference/compose-cli/#lythonic.compose.cli--key-concepts","title":"Key Concepts","text":"<ul> <li>ActionTree: A node in the command tree. Can have child actions and arguments.</li> <li>Main: Default root model with <code>--help</code> flag. Use as the root ActionTree argument.</li> <li>RunContext: Passed to actions that need it (declare <code>ctx: RunContext</code> as first param).   Provides access to parent values via <code>ctx.path.get('/path')</code>.</li> <li>Arguments: Required params become positional args; optional params become <code>--flags</code>.</li> <li>Pydantic integration: BaseModel fields provide descriptions and defaults automatically.</li> </ul>"},{"location":"reference/compose-cli/#lythonic.compose.cli--argument-parsing-rules","title":"Argument Parsing Rules","text":"<ul> <li>Required function params \u2192 positional arguments: <code>&lt;arg&gt;</code></li> <li>Optional function params \u2192 options: <code>--name=value</code> or <code>--name value</code></li> <li>Boolean params with <code>default=False</code> \u2192 flags: <code>--verbose</code> (no value needed)</li> <li>Pydantic models can be passed as JSON: <code>mycli config set '{\"name\":\"test\"}'</code></li> </ul>"},{"location":"reference/compose-cli/#lythonic.compose.cli.ActionTree","title":"<code>ActionTree</code>","text":"<p>               Bases: <code>Method</code></p> <p>A node in the command tree that can have child actions.</p> <p>Extends Method with the ability to register subcommands via the <code>actions</code> MethodDict. Call <code>run_args(sys.argv)</code> on the root to parse and execute.</p> Source code in <code>src/lythonic/compose/cli.py</code> <pre><code>class ActionTree(Method):\n    \"\"\"\n    A node in the command tree that can have child actions.\n\n    Extends Method with the ability to register subcommands via the `actions`\n    MethodDict. Call `run_args(sys.argv)` on the root to parse and execute.\n    \"\"\"\n\n    actions: MethodDict[ActionTree]\n\n    def __init__(self, o: Callable[..., Any] | GlobalRef):\n        super().__init__(o)\n        self.actions = MethodDict[ActionTree](method_type=self.__class__)\n\n    def run_args(\n        self, argv: list[str], print_func: Callable[[str], None] | None = print\n    ) -&gt; RunResult:\n        cli_name = Path(argv[0]).name\n        cli_args = argv[1:]\n        return self._run_args(cli_args, RunContext(self, cli_name, print_func))\n\n    def _split_ctx_args_opts(self) -&gt; tuple[bool, list[ArgInfo], list[ArgInfo]]:\n        has_ctx: bool = (\n            len(self.args) &gt; 0\n            and self.args[0].name == \"ctx\"\n            and self.args[0].annotation == RunContext\n        )\n        self_args = self.args[1:] if has_ctx else self.args\n        return (\n            has_ctx,\n            [arg for arg in self_args if not arg.is_optional],\n            [arg for arg in self_args if arg.is_optional],\n        )\n\n    def _run_args(self, cli_args: list[str], ctx: RunContext) -&gt; RunResult:\n        current_arg_index = 0\n        arg_values = {}\n        has_ctx, required_args, _ = self._split_ctx_args_opts()\n        if has_ctx:\n            arg_values[\"ctx\"] = ctx\n        error = None\n        try:\n            while current_arg_index &lt; len(cli_args):\n                arg_str = cli_args[current_arg_index]\n                if required_args:\n                    arg = required_args[0]\n                    if arg_str.startswith(\"--\"):\n                        raise ValueError(\n                            f\"Argument {arg.name} is required, but getting option {arg_str}\"\n                        )\n                    current_arg_index += 1\n                    arg_values[arg.name] = arg.to_value(arg_str)\n                    required_args.pop(0)\n                    continue\n                if arg_str.startswith(\"--\"):\n                    arg_str = arg_str[2:]\n                    if \"=\" in arg_str:\n                        k, v = arg_str.split(\"=\", 1)\n                    else:\n                        k = arg_str\n                        v = None\n                    if k in arg_values:\n                        raise ValueError(f\"--{k} is already set to {arg_values[k]}\")\n                    if k not in self.args_by_name:\n                        raise ValueError(\n                            f\"--{k} is not a valid option, expected one of {list(map(lambda x: f'--{x}', self.args_by_name.keys()))}\"\n                        )\n                    arg = self.args_by_name[k]\n                    if v is None:\n                        if arg.is_turn_on_option():\n                            v = \"y\"\n                        else:\n                            current_arg_index += 1\n                            if current_arg_index &gt;= len(cli_args):\n                                raise ValueError(f\"Value is not provided for --{k}\")\n                            v = cli_args[current_arg_index]\n                    arg_values[k] = arg.to_value(v)\n                    current_arg_index += 1\n                    continue\n                elif arg_str in self.actions:\n                    action: ActionTree = self.actions[arg_str]\n                    ctx.path.value = self(**arg_values)\n                    ctx.add_path(arg_str)\n                    return action._run_args(cli_args[current_arg_index + 1 :], ctx)\n                raise ValueError(f\"Argument {arg_str!r} is not a valid\")\n            if required_args:\n                raise ValueError(\n                    f\"Required arguments are missing: {' '.join(f'&lt;{arg.name}&gt;' for arg in required_args)}\"\n                )\n            if self.actions:\n                raise ValueError(\n                    f\"Action need to be specified, expected one of {', '.join(self.actions.keys())}\"\n                )\n        except Exception:\n            error = str(sys.exc_info()[1])\n        if error or ctx.is_print_help_selected():\n            ctx.print_help(error, ctx.path, self)\n        else:\n            ctx.path.value = self(**arg_values)\n            ctx.run_result.success = True\n        return ctx.run_result\n</code></pre>"},{"location":"reference/compose-cli/#lythonic.compose.cli.Main","title":"<code>Main</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Default root action model. Provides the <code>--help</code> flag.</p> Source code in <code>src/lythonic/compose/cli.py</code> <pre><code>class Main(BaseModel):\n    \"\"\"Default root action model. Provides the `--help` flag.\"\"\"\n\n    help: bool = Field(default=False, description=\"Show help\")\n</code></pre>"},{"location":"reference/compose-cli/#lythonic.compose.cli.RunContext","title":"<code>RunContext</code>","text":"<p>Context passed to action functions during CLI execution.</p> <p>Declare <code>ctx: RunContext</code> as the first parameter of an action to receive it. Use <code>ctx.path.get('/action_name')</code> to access parsed values from parent actions. Use <code>ctx.print()</code> for output that gets captured in <code>RunResult.msgs</code>.</p> Source code in <code>src/lythonic/compose/cli.py</code> <pre><code>class RunContext:\n    \"\"\"\n    Context passed to action functions during CLI execution.\n\n    Declare `ctx: RunContext` as the first parameter of an action to receive it.\n    Use `ctx.path.get('/action_name')` to access parsed values from parent actions.\n    Use `ctx.print()` for output that gets captured in `RunResult.msgs`.\n    \"\"\"\n\n    path: PathValue\n    main_at: ActionTree\n    run_result: RunResult\n    cli_name: str\n\n    def __init__(\n        self, main_at: ActionTree, cli_name: str, print_func: Callable[[str], None] | None = print\n    ):\n        self.path = PathValue.root()\n        self.main_at = main_at\n        self.run_result = RunResult(print_func=print_func)\n        self.cli_name = cli_name\n\n    def add_path(self, path: str):\n        self.path = PathValue(path, self.path)\n\n    def is_print_help_selected(self) -&gt; bool:\n        v = self.path.get(\"/\")\n        if isinstance(v, Main):\n            return v.help\n        return False\n\n    def print(self, msg: str):\n        self.run_result.print(msg)\n\n    def _recursive_help(self, print_at: ActionTree, indent: int):\n        indent += 2\n        _, arguments, options = print_at._split_ctx_args_opts()  # pyright: ignore[reportPrivateUsage]\n        for arg in arguments:\n            self.print(arg.arg_help(indent))\n        for opt in options:\n            self.print(opt.opt_help(indent))\n        if print_at.actions:\n            self.print(f\"{' ' * indent}Actions:\")\n            indent += 2\n            for action_name, action in print_at.actions.items():\n                self.print(f\"{' ' * indent}{action_name} - {action.doc}\")\n                self._recursive_help(action, indent + 2)\n\n    def print_help(self, error: str | None, path: PathValue, current_at: ActionTree):\n        if error:\n            self.print(f\"Error: {error}\")\n        self.print(\"Usage: \")\n        self.print(f\"  {self.cli_name} {' '.join(path.parts[1:])}\")\n        self._recursive_help(current_at, 2)\n</code></pre>"},{"location":"reference/compose-cli/#lythonic.compose.cli.RunResult","title":"<code>RunResult</code>","text":"<p>Result of running a CLI command, with success status and collected messages.</p> Source code in <code>src/lythonic/compose/cli.py</code> <pre><code>class RunResult:\n    \"\"\"Result of running a CLI command, with success status and collected messages.\"\"\"\n\n    success: bool\n    msgs: list[str]\n    print_func: Callable[[str], None] | None\n\n    def __init__(self, success: bool = False, print_func: Callable[[str], None] | None = print):\n        self.success = success\n        self.msgs = []\n        self.print_func = print_func\n\n    def print(self, msg: str):\n        if self.print_func is None:\n            self.msgs.append(msg)\n        else:\n            self.print_func(msg)\n</code></pre>"},{"location":"reference/compose-cli/#lythonic.compose.cli.PathValue","title":"<code>PathValue</code>","text":"<p>Records values along a path.</p> <pre><code>&gt;&gt;&gt; root = PathValue.root()\n&gt;&gt;&gt; root.value = \"I am Groot\"\n&gt;&gt;&gt; foo = PathValue(\"foo\", root, \"I am foo\")\n&gt;&gt;&gt; foo.get(\"/foo\")\n'I am foo'\n&gt;&gt;&gt; foo.parts\n('', 'foo')\n&gt;&gt;&gt; root.parts\n('',)\n&gt;&gt;&gt; foo.get(\"/bar\")\nTraceback (most recent call last):\n...\nValueError: Path /bar is not contained in /foo\n&gt;&gt;&gt; foo.get(\"/foo/\")\n'I am foo'\n&gt;&gt;&gt; foo.get(\"/\")\n'I am Groot'\n</code></pre> Source code in <code>src/lythonic/compose/cli.py</code> <pre><code>class PathValue:\n    \"\"\"\n    Records values along a path.\n\n    &gt;&gt;&gt; root = PathValue.root()\n    &gt;&gt;&gt; root.value = \"I am Groot\"\n    &gt;&gt;&gt; foo = PathValue(\"foo\", root, \"I am foo\")\n    &gt;&gt;&gt; foo.get(\"/foo\")\n    'I am foo'\n    &gt;&gt;&gt; foo.parts\n    ('', 'foo')\n    &gt;&gt;&gt; root.parts\n    ('',)\n    &gt;&gt;&gt; foo.get(\"/bar\")\n    Traceback (most recent call last):\n    ...\n    ValueError: Path /bar is not contained in /foo\n    &gt;&gt;&gt; foo.get(\"/foo/\")\n    'I am foo'\n    &gt;&gt;&gt; foo.get(\"/\")\n    'I am Groot'\n\n\n    \"\"\"\n\n    name: str\n    parent: PathValue | None\n    value: Any | None\n\n    def __init__(self, name: str, parent: PathValue | None, value: Any | None = None) -&gt; None:\n        if name == \"\":\n            assert parent is None\n        else:\n            assert parent is not None\n        self.name = name\n        self.parent = parent\n        self.value = value\n\n    @classmethod\n    def root(cls) -&gt; PathValue:\n        return cls(name=\"\", parent=None)\n\n    @property\n    def parts(self) -&gt; tuple[str, ...]:\n        if self.parent is None:\n            return (self.name,)\n        return (*self.parent.parts, self.name)\n\n    def get_back(self, n: int) -&gt; Any | None:\n        if n == 0:\n            return self.value\n        if self.parent is None:\n            return None\n        return self.parent.get_back(n - 1)\n\n    def get(self, path: str) -&gt; Any | None:\n        parts = self.parts\n        lookup_parts = tuple(path.split(\"/\"))\n        if lookup_parts[-1] == \"\":\n            lookup_parts = lookup_parts[:-1]\n        lpl = len(lookup_parts)\n        pl = len(parts)\n        if parts[:lpl] != lookup_parts:\n            raise ValueError(f\"Path {path} is not contained in {self}\")\n        return self.get_back(pl - lpl)\n\n    @override\n    def __str__(self):\n        return \"/\".join(self.parts)\n</code></pre>"},{"location":"reference/compose-logic/","title":"lythonic.compose.logic","text":"<p>Build typed logic graphs from annotated functions.</p> <p>Logic: Build typed logic graphs from annotated functions.</p> <p>This module provides primitives for composing typed functions into logic graphs where nodes are functions that accept and return Pydantic BaseModels.</p>"},{"location":"reference/compose-logic/#lythonic.compose.logic--core-concepts","title":"Core Concepts","text":"<ul> <li><code>LogicNode</code>: Wrapper around a function with typed BaseModel inputs/outputs</li> <li><code>LogicGraph</code>: A graph of LogicNodes (start/end nodes + named nodes)</li> <li><code>PossibleTypes</code>: Union type tracking for error types</li> </ul>"},{"location":"reference/compose-logic/#lythonic.compose.logic--usage","title":"Usage","text":"<pre><code>from pydantic import BaseModel\nfrom lythonic.compose.logic import LogicNode\n\nclass Input(BaseModel):\n    value: int\n\nclass Output(BaseModel):\n    result: int\n\ndef double(input: Input) -&gt; Output:\n    return Output(result=input.value * 2)\n\nnode = LogicNode(double)\n# node.input_types == [Input]\n# node.ok_output_types == [Output]\n</code></pre> <p>Functions can also return <code>Result[T, E]</code> for explicit error handling:</p> <pre><code>from lythonic import Result\n\ndef safe_divide(input: Input) -&gt; Result[Output, ZeroDivisionError]:\n    if input.value == 0:\n        return Result.Err(ZeroDivisionError())\n    return Result.Ok(Output(result=100 // input.value))\n</code></pre>"},{"location":"reference/compose-logic/#lythonic.compose.logic.LogicNode","title":"<code>LogicNode</code>","text":"<p>Wrapper around a typed function for use in logic graphs.</p> <p>Analyzes the function signature to extract: - <code>input_types</code>: List of BaseModel types accepted as arguments - <code>ok_output_types</code>: List of BaseModel types returned on success - <code>err_output_type</code>: PossibleTypes for error cases (if using Result)</p> <p>The function must accept zero or more BaseModel arguments and return either a BaseModel, tuple of BaseModels, or Result[BaseModel, E].</p> Source code in <code>src/lythonic/compose/logic.py</code> <pre><code>class LogicNode:\n    \"\"\"\n    Wrapper around a typed function for use in logic graphs.\n\n    Analyzes the function signature to extract:\n    - `input_types`: List of BaseModel types accepted as arguments\n    - `ok_output_types`: List of BaseModel types returned on success\n    - `err_output_type`: PossibleTypes for error cases (if using Result)\n\n    The function must accept zero or more BaseModel arguments and return\n    either a BaseModel, tuple of BaseModels, or Result[BaseModel, E].\n    \"\"\"\n\n    logic: Callable[[Any], Any]\n    input_types: list[type[BaseModel]]\n    ok_output_types: list[type[BaseModel]]\n    err_output_type: PossibleTypes | None\n\n    def __init__(self, logic: Callable[[Any], Any]) -&gt; None:\n        method = Method(logic)\n        self.input_types = []\n        self.ok_output_types = []\n        self.err_output_type = None\n        for ai in method.args:\n            assert isinstance(ai.annotation, type) and issubclass(ai.annotation, BaseModel), (\n                f\"Only BaseModel is allowed as input type but got argument {ai}\"\n            )\n            self.input_types.append(ai.annotation)\n\n        return_type = method.return_annotation\n        if get_origin(return_type) is Result:\n            # Result[BaseModel|tuple[BaseModel, ...], Any] case\n            args = get_args(return_type)\n            ok_type = args[0] if args else None\n            err_type = args[1] if len(args) &gt; 1 else None\n            assert ok_type is not None, (\n                f\"Result[TOk, TErr] requires BaseModel as TOk but got {ok_type}\"\n            )\n            self.ok_output_types.extend(_unpack_base_model_tuple(ok_type))\n            # TODO: unpack union type for err_type, and validate it is not a BaseModels, it is probably bare exceptions.\n            if err_type is not None:\n                self.err_output_type = PossibleTypes(err_type)\n        else:\n            self.ok_output_types.extend(_unpack_base_model_tuple(return_type))\n\n        self.logic = logic\n</code></pre>"},{"location":"reference/compose-logic/#lythonic.compose.logic.LogicGraph","title":"<code>LogicGraph</code>","text":"<p>A directed graph of LogicNodes representing a workflow.</p> <p>Currently a placeholder for future workflow composition features.</p> Source code in <code>src/lythonic/compose/logic.py</code> <pre><code>class LogicGraph:\n    \"\"\"\n    A directed graph of LogicNodes representing a workflow.\n\n    Currently a placeholder for future workflow composition features.\n    \"\"\"\n\n    start_node: LogicNode | None\n    end_node: LogicNode | None\n    nodes: dict[str, LogicNode]\n\n    def __init__(self) -&gt; None:\n        self.start_node = None\n        self.end_node = None\n        self.nodes = {}\n</code></pre>"},{"location":"reference/compose-logic/#lythonic.compose.logic.PossibleTypes","title":"<code>PossibleTypes</code>","text":"<p>Represents a union of types, tracking which are BaseModels vs exceptions.</p> <p>Used to analyze error return types in <code>Result[T, E]</code> signatures.</p> <pre><code>&gt;&gt;&gt; x = PossibleTypes(BaseModel|BaseException)\n&gt;&gt;&gt; x.which_are_base_models()\n[True, False]\n&gt;&gt;&gt; str(x)\n'BaseModel|BaseException'\n&gt;&gt;&gt; x = PossibleTypes(BaseModel,include_all_exceptions=True)\n&gt;&gt;&gt; x\nPossibleTypes(BaseModel|BaseException)\n&gt;&gt;&gt; all(x.which_are_base_models())\nFalse\n&gt;&gt;&gt; x = PossibleTypes(BaseModel)\n&gt;&gt;&gt; all(x.which_are_base_models())\nTrue\n</code></pre> Source code in <code>src/lythonic/compose/logic.py</code> <pre><code>class PossibleTypes:\n    \"\"\"\n    Represents a union of types, tracking which are BaseModels vs exceptions.\n\n    Used to analyze error return types in `Result[T, E]` signatures.\n\n    &gt;&gt;&gt; x = PossibleTypes(BaseModel|BaseException)\n    &gt;&gt;&gt; x.which_are_base_models()\n    [True, False]\n    &gt;&gt;&gt; str(x)\n    'BaseModel|BaseException'\n    &gt;&gt;&gt; x = PossibleTypes(BaseModel,include_all_exceptions=True)\n    &gt;&gt;&gt; x\n    PossibleTypes(BaseModel|BaseException)\n    &gt;&gt;&gt; all(x.which_are_base_models())\n    False\n    &gt;&gt;&gt; x = PossibleTypes(BaseModel)\n    &gt;&gt;&gt; all(x.which_are_base_models())\n    True\n\n    \"\"\"\n\n    types: list[Any]\n\n    def __init__(self, annotation: Any, include_all_exceptions: bool = False) -&gt; None:\n        self.types = []\n        origin = get_origin(annotation)\n        if origin is UnionType:\n            for arg in get_args(annotation):\n                self.types.append(arg)\n        else:\n            self.types.append(annotation)\n        if include_all_exceptions:\n            self.types.append(BaseException)\n\n    def which_are_base_models(self) -&gt; list[bool]:\n        return [isinstance(t, type) and issubclass(t, BaseModel) for t in self.types]\n\n    @override\n    def __str__(self):\n        return \"|\".join(t.__name__ if isinstance(t, type) else str(t) for t in self.types)\n\n    @override\n    def __repr__(self):\n        return f\"PossibleTypes({str(self)})\"\n</code></pre>"},{"location":"reference/compose/","title":"lythonic.compose","text":"<p>Build typed callable compositions from annotated functions.</p> <p>Compose: Build typed callable compositions from annotated functions.</p> <p>This module provides introspection and composition primitives for building higher-level structures (CLIs, pipelines, workflows) from type-annotated callables.</p>"},{"location":"reference/compose/#lythonic.compose--core-concepts","title":"Core Concepts","text":"<ul> <li><code>Method</code>: Wrapper around a callable with signature introspection</li> <li><code>MethodDict</code>: Dictionary of methods indexed by name</li> <li><code>ArgInfo</code>: Metadata about function arguments</li> </ul>"},{"location":"reference/compose/#lythonic.compose--cli-support","title":"CLI Support","text":"<p>For building command-line interfaces, see <code>lythonic.compose.cli</code>:</p> <pre><code>from lythonic.compose.cli import ActionTree, Main, RunContext\n</code></pre>"},{"location":"reference/compose/#lythonic.compose.Method","title":"<code>Method</code>","text":"<p>Wrapper around a callable that provides introspection of its arguments.</p> <p>Lazily loads the callable via GlobalRef and extracts argument metadata from the function signature. Supports both regular functions and Pydantic BaseModel classes (using their <code>__init__</code> signature).</p> Source code in <code>src/lythonic/compose/__init__.py</code> <pre><code>class Method:\n    \"\"\"\n    Wrapper around a callable that provides introspection of its arguments.\n\n    Lazily loads the callable via GlobalRef and extracts argument metadata\n    from the function signature. Supports both regular functions and Pydantic\n    BaseModel classes (using their `__init__` signature).\n    \"\"\"\n\n    gref: GlobalRef\n    _o: Callable[..., Any] | None\n    _args: list[ArgInfo] | None\n    _args_by_name: dict[str, ArgInfo] | None\n    _return_annotation: Any | None\n\n    def __init__(self, o: Callable[..., Any] | GlobalRef):\n        if isinstance(o, GlobalRef):\n            self.gref = o\n            self._o = None\n        else:\n            self.gref = GlobalRef(o)\n            assert isinstance(o, Callable), \"method instance must be a callable\"\n            self._o = o\n        self._args = None\n        self._args_by_name = None\n        self._return_annotation = None\n\n    def _update_from_signature(self):\n        o = self.o\n        sig = inspect.signature(o)\n        self._args = [ArgInfo.from_param(param, origin=o) for param in sig.parameters.values()]\n        self._args_by_name = {arg.name: arg for arg in self._args}\n        self._return_annotation = sig.return_annotation\n\n    @property\n    def o(self) -&gt; Callable[..., Any]:\n        if self._o is None:\n            self._o = self.gref.get_instance()\n        assert self._o is not None\n        return self._o\n\n    @property\n    def args(self) -&gt; list[ArgInfo]:\n        if self._args is None:\n            self._update_from_signature()\n        assert self._args is not None\n        return self._args\n\n    @property\n    def args_by_name(self) -&gt; dict[str, ArgInfo]:\n        if self._args_by_name is None:\n            self._update_from_signature()\n        assert self._args_by_name is not None\n        return self._args_by_name\n\n    @property\n    def return_annotation(self) -&gt; Any | None:\n        if self._args is None:\n            self._update_from_signature()\n        return self._return_annotation\n\n    @property\n    def name(self):\n        return self.gref.name\n\n    @property\n    def doc(self):\n        return self.o.__doc__\n\n    def __call__(self, *args: Any, **kwargs: Any):\n        return self.o(*args, **kwargs)\n</code></pre>"},{"location":"reference/compose/#lythonic.compose.MethodDict","title":"<code>MethodDict</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>dict[str, T]</code></p> <p>Dictionary mapping lowercased method names to Method instances.</p> <p>Use <code>add()</code> to register a callable, or <code>wrap()</code> as a decorator.</p> Source code in <code>src/lythonic/compose/__init__.py</code> <pre><code>class MethodDict(Generic[T], dict[str, T]):\n    \"\"\"\n    Dictionary mapping lowercased method names to Method instances.\n\n    Use `add()` to register a callable, or `wrap()` as a decorator.\n    \"\"\"\n\n    method_type: type[T]\n\n    def __init__(self, method_type: type[T]):\n        super().__init__()\n        self.method_type = method_type\n\n    def add(self, o: Callable[..., Any]) -&gt; T:\n        m = self.method_type(o)\n        self[m.name.lower()] = m\n        return m\n\n    def wrap(self, o: Callable[..., Any]) -&gt; T:\n        return self.add(o)\n</code></pre>"},{"location":"reference/compose/#lythonic.compose.ArgInfo","title":"<code>ArgInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Metadata about a function argument, extracted from signature and Pydantic fields.</p> <p>Used to generate CLI argument/option parsing and help text.</p> Source code in <code>src/lythonic/compose/__init__.py</code> <pre><code>class ArgInfo(NamedTuple):\n    \"\"\"\n    Metadata about a function argument, extracted from signature and Pydantic fields.\n\n    Used to generate CLI argument/option parsing and help text.\n    \"\"\"\n\n    name: str\n    annotation: Any | None\n    default: Any | None\n    is_optional: bool\n    description: str\n\n    @classmethod\n    def from_param(cls, param: inspect.Parameter, origin: Any):\n        description = \"\"\n        is_optional = param.default != inspect.Parameter.empty\n        default = param.default if is_optional else None\n        if isinstance(origin, type) and issubclass(origin, BaseModel):\n            if param.name in origin.model_fields:\n                field = origin.model_fields[param.name]\n                if field.description is not None:\n                    description = field.description\n                is_optional = not field.is_required()\n                default = field.default\n        return cls(\n            name=param.name,\n            annotation=param.annotation if param.annotation != inspect.Parameter.empty else None,\n            default=default,\n            is_optional=is_optional,\n            description=description,\n        )\n\n    def to_value(self, v: str):\n        if self.annotation is None:\n            return v\n        if self.annotation is bool:\n            return v.lower() in (\"true\", \"1\", \"yes\", \"y\")\n        if issubclass(self.annotation, BaseModel):\n            return self.annotation.model_validate_json(v)\n        return self.annotation(v)\n\n    def is_turn_on_option(self) -&gt; bool:\n        return self.annotation is bool and self.default is False\n\n    @property\n    def type(self) -&gt; str:\n        if self.annotation is not None:\n            return self.annotation.__name__\n        return \"str\"\n\n    def arg_help(self, indent: int):\n        return f\"{' ' * indent}&lt;{self.name}&gt; - {self.type}: {self.description}\"\n\n    def opt_help(self, indent: int):\n        return f\"{' ' * indent}[--{self.name}{'=value' if not self.is_turn_on_option() else ''}] - {self.type}: {self.description}. Default: {self.default!r}\"\n</code></pre>"},{"location":"reference/core/","title":"lythonic","text":"<p>Core utilities: global references, Result type, and helpers.</p> <p>Core utilities for the Lythonic library.</p> <p>This module provides foundational types and utilities used throughout Lythonic:</p> <ul> <li><code>GlobalRef</code> / <code>GRef</code>: Reference any Python object by its module path (e.g., <code>\"mymodule:MyClass\"</code>).   Useful for configuration files and lazy loading.</li> <li><code>Result[TOk, TErr]</code>: A Rust-inspired Result type for explicit error handling without exceptions.</li> <li><code>utc_now()</code>: Get the current UTC datetime.</li> <li><code>get_module()</code>: Import a module by name.</li> </ul>"},{"location":"reference/core/#lythonic--globalref-usage","title":"GlobalRef Usage","text":"<pre><code>from lythonic import GlobalRef\n\n# Reference a class by string\nref = GlobalRef(\"json:dumps\")\ndumps_func = ref.get_instance()\n\n# Reference from an object\nref = GlobalRef(MyClass)\nprint(ref)  # \"mymodule:MyClass\"\n</code></pre>"},{"location":"reference/core/#lythonic--result-usage","title":"Result Usage","text":"<pre><code>from lythonic import Result\n\ndef divide(a: int, b: int) -&gt; Result[float, str]:\n    if b == 0:\n        return Result.Err(\"division by zero\")\n    return Result.Ok(a / b)\n\nresult = divide(10, 2)\nif result.is_ok():\n    print(result.unwrap())  # 5.0\n</code></pre>"},{"location":"reference/core/#lythonic.GRef","title":"<code>GRef = Annotated[GlobalRef, PlainSerializer(str, return_type=str), AfterValidator(GlobalRef), WithJsonSchema({'type': 'string'}, mode='serialization')]</code>  <code>module-attribute</code>","text":""},{"location":"reference/core/#lythonic.GlobalRef","title":"<code>GlobalRef</code>","text":"<pre><code>&gt;&gt;&gt; ref = GlobalRef('lythonic:GlobalRef')\n&gt;&gt;&gt; ref\nGlobalRef('lythonic:GlobalRef')\n&gt;&gt;&gt; ref.get_instance().__name__\n'GlobalRef'\n&gt;&gt;&gt; ref.is_module()\nFalse\n&gt;&gt;&gt; ref.get_module().__name__\n'lythonic'\n&gt;&gt;&gt; grgr = GlobalRef(GlobalRef)\n&gt;&gt;&gt; grgr\nGlobalRef('lythonic:GlobalRef')\n&gt;&gt;&gt; grgr.get_instance()\n&lt;class 'lythonic.GlobalRef'&gt;\n&gt;&gt;&gt; grgr.is_class()\nTrue\n&gt;&gt;&gt; grgr.is_function()\nFalse\n&gt;&gt;&gt; grgr.is_module()\nFalse\n&gt;&gt;&gt; uref = GlobalRef('lythonic:')\n&gt;&gt;&gt; uref.is_module()\nTrue\n&gt;&gt;&gt; uref.get_module().__name__\n'lythonic'\n&gt;&gt;&gt; uref = GlobalRef('lythonic')\n&gt;&gt;&gt; uref.is_module()\nTrue\n&gt;&gt;&gt; uref = GlobalRef(uref)\n&gt;&gt;&gt; uref.is_module()\nTrue\n&gt;&gt;&gt; uref.get_module().__name__\n'lythonic'\n&gt;&gt;&gt; uref = GlobalRef(uref.get_module())\n&gt;&gt;&gt; uref.is_module()\nTrue\n&gt;&gt;&gt; uref.get_module().__name__\n'lythonic'\n</code></pre> Source code in <code>src/lythonic/__init__.py</code> <pre><code>class GlobalRef:\n    \"\"\"\n    &gt;&gt;&gt; ref = GlobalRef('lythonic:GlobalRef')\n    &gt;&gt;&gt; ref\n    GlobalRef('lythonic:GlobalRef')\n    &gt;&gt;&gt; ref.get_instance().__name__\n    'GlobalRef'\n    &gt;&gt;&gt; ref.is_module()\n    False\n    &gt;&gt;&gt; ref.get_module().__name__\n    'lythonic'\n    &gt;&gt;&gt; grgr = GlobalRef(GlobalRef)\n    &gt;&gt;&gt; grgr\n    GlobalRef('lythonic:GlobalRef')\n    &gt;&gt;&gt; grgr.get_instance()\n    &lt;class 'lythonic.GlobalRef'&gt;\n    &gt;&gt;&gt; grgr.is_class()\n    True\n    &gt;&gt;&gt; grgr.is_function()\n    False\n    &gt;&gt;&gt; grgr.is_module()\n    False\n    &gt;&gt;&gt; uref = GlobalRef('lythonic:')\n    &gt;&gt;&gt; uref.is_module()\n    True\n    &gt;&gt;&gt; uref.get_module().__name__\n    'lythonic'\n    &gt;&gt;&gt; uref = GlobalRef('lythonic')\n    &gt;&gt;&gt; uref.is_module()\n    True\n    &gt;&gt;&gt; uref = GlobalRef(uref)\n    &gt;&gt;&gt; uref.is_module()\n    True\n    &gt;&gt;&gt; uref.get_module().__name__\n    'lythonic'\n    &gt;&gt;&gt; uref = GlobalRef(uref.get_module())\n    &gt;&gt;&gt; uref.is_module()\n    True\n    &gt;&gt;&gt; uref.get_module().__name__\n    'lythonic'\n    \"\"\"\n\n    module: str\n    name: str\n\n    def __init__(self, s: Any) -&gt; None:\n        if isinstance(s, GlobalRef):\n            self.module, self.name = s.module, s.name\n        elif ismodule(s):\n            self.module, self.name = s.__name__, \"\"\n        elif isclass(s) or isfunction(s):\n            self.module, self.name = s.__module__, s.__name__\n        else:\n            split = s.split(\":\")\n            if len(split) == 1:\n                assert bool(split[0]), f\"is {repr(s)} empty?\"\n                split.append(\"\")\n            else:\n                assert len(split) == 2, f\"too many ':' in: {repr(s)}\"\n            self.module, self.name = split\n\n    @override\n    def __str__(self):\n        return f\"{self.module}:{self.name}\"\n\n    @override\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({repr(str(self))})\"\n\n    @override\n    def __eq__(self, other: Any) -&gt; bool:\n        return str(self) == str(other)\n\n    @override\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    @override\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self == other\n\n    def get_module(self) -&gt; ModuleType:\n        return __import__(self.module, fromlist=[\"\"])\n\n    def is_module(self) -&gt; bool:\n        return not (self.name)\n\n    def is_class(self) -&gt; bool:\n        return not (self.is_module()) and isclass(self.get_instance())\n\n    def is_function(self) -&gt; bool:\n        return not (self.is_module()) and isfunction(self.get_instance())\n\n    def is_async(self) -&gt; bool:\n        if self.is_module():\n            return False\n        if self.is_class():\n            return iscoroutinefunction(self.get_instance().__call__)\n        return iscoroutinefunction(self.get_instance())\n\n    def get_instance(self) -&gt; Any:\n        assert not self.is_module(), f\"{repr(self)}.get_module() only\"\n        attr = getattr(self.get_module(), self.name)\n        return attr\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n</code></pre>"},{"location":"reference/core/#lythonic.Result","title":"<code>Result</code>","text":"<p>               Bases: <code>Generic[TOk, TErr]</code></p> <p>A generic Result type inspired by Rust, representing either success (Ok) or failure (Err).</p> Source code in <code>src/lythonic/__init__.py</code> <pre><code>@final\nclass Result(Generic[TOk, TErr]):\n    \"\"\"\n    A generic Result type inspired by Rust, representing either success (Ok) or failure (Err).\n    \"\"\"\n\n    _ok: TOk | None\n    _err: TErr | None\n\n    __slots__ = (\"_ok\", \"_err\")\n\n    def __init__(self, ok: TOk | None = None, err: TErr | None = None) -&gt; None:\n        assert (ok is None and err is not None) or (ok is not None and err is None), (\n            \"Result can only have one of ok or err set.\"\n        )\n        self._ok = ok\n        self._err = err\n\n    @classmethod\n    def Ok(cls, value: TOk) -&gt; \"Result[TOk, TErr]\":\n        return cls(ok=value)\n\n    @classmethod\n    def Err(cls, error: TErr) -&gt; \"Result[TOk, TErr]\":\n        return cls(err=error)\n\n    def is_ok(self) -&gt; bool:\n        return self._ok is not None\n\n    def is_err(self) -&gt; bool:\n        return self._err is not None\n\n    def ok(self) -&gt; TOk | None:\n        return self._ok\n\n    def err(self) -&gt; TErr | None:\n        return self._err\n\n    def unwrap(self) -&gt; TOk:\n        if self._ok is not None:\n            return self._ok\n        raise ValueError(f\"Called unwrap on Err: {self._err}\")\n\n    def unwrap_err(self) -&gt; TErr:\n        if self._err is not None:\n            return self._err\n        raise ValueError(f\"Called unwrap_err on Ok: {self._ok}\")\n\n    @override\n    def __repr__(self):\n        if self.is_ok():\n            return f\"Ok({self._ok!r})\"\n        else:\n            return f\"Err({self._err!r})\"\n</code></pre>"},{"location":"reference/core/#lythonic.get_module","title":"<code>get_module(name)</code>","text":"<pre><code>&gt;&gt;&gt; type(get_module('lythonic'))\n&lt;class 'module'&gt;\n&gt;&gt;&gt; get_module('lythonic.c99')\nTraceback (most recent call last):\n...\nModuleNotFoundError: No module named 'lythonic.c99'\n</code></pre> Source code in <code>src/lythonic/__init__.py</code> <pre><code>def get_module(name: str) -&gt; ModuleType:\n    \"\"\"\n    &gt;&gt;&gt; type(get_module('lythonic'))\n    &lt;class 'module'&gt;\n    &gt;&gt;&gt; get_module('lythonic.c99')\n    Traceback (most recent call last):\n    ...\n    ModuleNotFoundError: No module named 'lythonic.c99'\n    \"\"\"\n    if name in sys.modules:\n        return sys.modules[name]\n    return __import__(name, fromlist=[\"\"])\n</code></pre>"},{"location":"reference/core/#lythonic.utc_now","title":"<code>utc_now()</code>","text":"<p>return the current time in UTC</p> <p>utc_now().tzinfo datetime.timezone.utc</p> Source code in <code>src/lythonic/__init__.py</code> <pre><code>def utc_now() -&gt; datetime:\n    \"\"\"return the current time in UTC\n    &gt;&gt;&gt; utc_now().tzinfo\n    datetime.timezone.utc\n    \"\"\"\n    return datetime.now(UTC)\n</code></pre>"},{"location":"reference/core/#lythonic.str_or_none","title":"<code>str_or_none(s)</code>","text":"<pre><code>&gt;&gt;&gt; str_or_none(None)\n&gt;&gt;&gt; str_or_none(5)\n'5'\n&gt;&gt;&gt; str_or_none('')\n''\n</code></pre> Source code in <code>src/lythonic/__init__.py</code> <pre><code>def str_or_none(s: Any) -&gt; str | None:\n    \"\"\"\n    &gt;&gt;&gt; str_or_none(None)\n    &gt;&gt;&gt; str_or_none(5)\n    '5'\n    &gt;&gt;&gt; str_or_none('')\n    ''\n    \"\"\"\n    return str(s) if s is not None else None\n</code></pre>"},{"location":"reference/misc/","title":"lythonic.misc","text":"<p>File system utilities.</p> <p>File system utilities.</p> <p>Helper functions for working with directories and paths.</p> <pre><code>from lythonic.misc import ensure_dir, tabula_rasa_path\nfrom pathlib import Path\n\n# Create directory if it doesn't exist\ndata_dir = ensure_dir(\"./data/cache\")\n\n# Clear a path (file or directory) and ensure parent exists\noutput = tabula_rasa_path(\"./output/results.json\")\n</code></pre>"},{"location":"reference/misc/#lythonic.misc.ensure_dir","title":"<code>ensure_dir(dir)</code>","text":"<p>Create directory and parents if they don't exist. Returns the Path.</p> Source code in <code>src/lythonic/misc.py</code> <pre><code>def ensure_dir(dir: Path | str) -&gt; Path:\n    \"\"\"Create directory and parents if they don't exist. Returns the Path.\"\"\"\n    dir = Path(dir)\n    dir.mkdir(parents=True, exist_ok=True)\n    return dir\n</code></pre>"},{"location":"reference/misc/#lythonic.misc.tabula_rasa_path","title":"<code>tabula_rasa_path(p)</code>","text":"<p>Ensure path doesn't exist but parent directory does.</p> <p>Removes the file or directory at the path if it exists, then ensures the parent directory exists. Returns the Path ready for writing.</p> Source code in <code>src/lythonic/misc.py</code> <pre><code>def tabula_rasa_path(p: Path | str) -&gt; Path:\n    \"\"\"\n    Ensure path doesn't exist but parent directory does.\n\n    Removes the file or directory at the path if it exists, then ensures\n    the parent directory exists. Returns the Path ready for writing.\n    \"\"\"\n    p = Path(p)\n    if p.exists():\n        if p.is_dir():\n            shutil.rmtree(p)\n        else:\n            p.unlink()\n    if not p.parent.is_dir():\n        ensure_dir(p.parent)\n    return p\n</code></pre>"},{"location":"reference/periodic/","title":"lythonic.periodic","text":"<p>Time and scheduling utilities.</p> <p>Time and scheduling utilities.</p> <p>This module provides tools for working with time intervals, frequencies, and periodic tasks:</p>"},{"location":"reference/periodic/#lythonic.periodic--time-simulation","title":"Time Simulation","text":"<p><code>SimulatedTime</code> allows testing time-dependent code by offsetting the clock:</p> <pre><code>from lythonic.periodic import stime\nfrom datetime import timedelta\n\nstime.set_offset(timedelta(days=1))  # Pretend it's tomorrow\nprint(stime.get_datetime())\nstime.reset()  # Back to real time\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic--frequencies-and-intervals","title":"Frequencies and Intervals","text":"<ul> <li><code>Frequency</code>: Human-friendly periods (weekly, monthly, quarterly, annually)</li> <li><code>FrequencyOffset</code>: Frequency with day offset (e.g., \"20th of each month\")</li> <li><code>Interval</code>: Precise duration with multiplier (e.g., \"3M\" for 3 months, \"2W\" for 2 weeks)</li> </ul> <pre><code>from lythonic.periodic import Frequency, Interval\nfrom datetime import date\n\nfreq = Frequency(\"monthly\")\nprint(freq.first_day(date(2025, 11, 15)))  # 2025-11-01\nprint(freq.last_day(date(2025, 11, 15)))   # 2025-11-30\n\ninterval = Interval.from_string(\"2W\")\nprint(interval.timedelta())  # 14 days\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic--periodic-tasks","title":"Periodic Tasks","text":"<p>Run async tasks at specified intervals:</p> <pre><code>from lythonic.periodic import PeriodicTask, run_all\n\ntask = PeriodicTask(freq=60, logic=my_function)  # Run every 60 seconds\nawait run_all(task)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic--timing-with-moment","title":"Timing with Moment","text":"<p>Track elapsed time between checkpoints:</p> <pre><code>from lythonic.periodic import Moment\n\nm = Moment.start()\n# ... do work ...\nm = m.capture(\"step1\")\n# ... more work ...\nm = m.capture(\"done\")\nprint(m.chain())  # [start] 0.5s-&gt; [step1] 1.2s-&gt; [done]\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.stime","title":"<code>stime = SimulatedTime()</code>  <code>module-attribute</code>","text":""},{"location":"reference/periodic/#lythonic.periodic.SimulatedTime","title":"<code>SimulatedTime</code>","text":"<pre><code>&gt;&gt;&gt; st = SimulatedTime()\n&gt;&gt;&gt; st.get_datetime().tzinfo\ndatetime.timezone.utc\n&gt;&gt;&gt; cmp = lambda ss: abs((st.get_datetime()-utc_now()).total_seconds()-ss) &lt; 1e-3\n&gt;&gt;&gt; cmp(0)\nTrue\n&gt;&gt;&gt; st.set_offset(timedelta(days=1))\n&gt;&gt;&gt; cmp(86400)\nTrue\n&gt;&gt;&gt; st.set_offset(timedelta(days=1).total_seconds())\n&gt;&gt;&gt; cmp(86400)\nTrue\n&gt;&gt;&gt; st.set_now(utc_now() + timedelta(days=1))\n&gt;&gt;&gt; cmp(86400)\nTrue\n&gt;&gt;&gt; st.set_now( (utc_now() - timedelta(days=1)).timestamp() )\n&gt;&gt;&gt; cmp(-86400)\nTrue\n&gt;&gt;&gt; st.is_real_time()\nFalse\n&gt;&gt;&gt; st.reset()\n&gt;&gt;&gt; st.is_real_time()\nTrue\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>class SimulatedTime:\n    \"\"\"\n    &gt;&gt;&gt; st = SimulatedTime()\n    &gt;&gt;&gt; st.get_datetime().tzinfo\n    datetime.timezone.utc\n    &gt;&gt;&gt; cmp = lambda ss: abs((st.get_datetime()-utc_now()).total_seconds()-ss) &lt; 1e-3\n    &gt;&gt;&gt; cmp(0)\n    True\n    &gt;&gt;&gt; st.set_offset(timedelta(days=1))\n    &gt;&gt;&gt; cmp(86400)\n    True\n    &gt;&gt;&gt; st.set_offset(timedelta(days=1).total_seconds())\n    &gt;&gt;&gt; cmp(86400)\n    True\n    &gt;&gt;&gt; st.set_now(utc_now() + timedelta(days=1))\n    &gt;&gt;&gt; cmp(86400)\n    True\n    &gt;&gt;&gt; st.set_now( (utc_now() - timedelta(days=1)).timestamp() )\n    &gt;&gt;&gt; cmp(-86400)\n    True\n    &gt;&gt;&gt; st.is_real_time()\n    False\n    &gt;&gt;&gt; st.reset()\n    &gt;&gt;&gt; st.is_real_time()\n    True\n    \"\"\"\n\n    offset: float\n\n    def __init__(self, offset: float = 0.0) -&gt; None:\n        self.offset = offset\n\n    def time(self):\n        return tt.time() + self.offset\n\n    def set_offset(self, offset: timedelta | float):\n        if isinstance(offset, timedelta):\n            self.offset = offset.total_seconds()\n        else:\n            self.offset = offset\n\n    def set_now(self, dt: datetime | float):\n        if isinstance(dt, datetime):\n            epoch = dt.timestamp()\n        else:\n            epoch = dt\n        self.offset = epoch - tt.time()\n\n    def reset(self):\n        self.offset = 0.0\n\n    def is_real_time(self):\n        return self.offset == 0.0\n\n    def get_datetime(self) -&gt; datetime:\n        return datetime.fromtimestamp(self.time(), tz=UTC)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.Frequency","title":"<code>Frequency</code>","text":"<p>People friendly interval</p> <pre><code>&gt;&gt;&gt; Frequency(\"weekly\").first_day(date(2025, 11, 21))\ndatetime.date(2025, 11, 17)\n&gt;&gt;&gt; Frequency(\"weekly\").last_day(date(2025, 11, 21))\ndatetime.date(2025, 11, 23)\n&gt;&gt;&gt; Frequency(\"monthly\").first_day(date(2025, 11, 21))\ndatetime.date(2025, 11, 1)\n&gt;&gt;&gt; Frequency(\"monthly\").last_day(date(2025, 11, 21))\ndatetime.date(2025, 11, 30)\n&gt;&gt;&gt; Frequency(\"quarterly\").first_day(date(2025, 11, 21))\ndatetime.date(2025, 10, 1)\n&gt;&gt;&gt; Frequency(\"quarterly\").last_day(date(2025, 11, 21))\ndatetime.date(2025, 12, 31)\n&gt;&gt;&gt; Frequency(\"quarterly\").first_day(date(2025, 2, 21))\ndatetime.date(2025, 1, 1)\n&gt;&gt;&gt; Frequency(\"quarterly\").last_day(date(2025, 2, 21))\ndatetime.date(2025, 3, 31)\n&gt;&gt;&gt; Frequency(\"quarterly\").last_day(date(2025, 5, 21))\ndatetime.date(2025, 6, 30)\n&gt;&gt;&gt; Frequency(\"annually\").first_day(date(2025, 11, 21))\ndatetime.date(2025, 1, 1)\n&gt;&gt;&gt; Frequency(\"annually\").last_day(date(2025, 11, 21))\ndatetime.date(2025, 12, 31)\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>class Frequency:\n    \"\"\"People friendly interval\n\n    &gt;&gt;&gt; Frequency(\"weekly\").first_day(date(2025, 11, 21))\n    datetime.date(2025, 11, 17)\n    &gt;&gt;&gt; Frequency(\"weekly\").last_day(date(2025, 11, 21))\n    datetime.date(2025, 11, 23)\n    &gt;&gt;&gt; Frequency(\"monthly\").first_day(date(2025, 11, 21))\n    datetime.date(2025, 11, 1)\n    &gt;&gt;&gt; Frequency(\"monthly\").last_day(date(2025, 11, 21))\n    datetime.date(2025, 11, 30)\n    &gt;&gt;&gt; Frequency(\"quarterly\").first_day(date(2025, 11, 21))\n    datetime.date(2025, 10, 1)\n    &gt;&gt;&gt; Frequency(\"quarterly\").last_day(date(2025, 11, 21))\n    datetime.date(2025, 12, 31)\n    &gt;&gt;&gt; Frequency(\"quarterly\").first_day(date(2025, 2, 21))\n    datetime.date(2025, 1, 1)\n    &gt;&gt;&gt; Frequency(\"quarterly\").last_day(date(2025, 2, 21))\n    datetime.date(2025, 3, 31)\n    &gt;&gt;&gt; Frequency(\"quarterly\").last_day(date(2025, 5, 21))\n    datetime.date(2025, 6, 30)\n    &gt;&gt;&gt; Frequency(\"annually\").first_day(date(2025, 11, 21))\n    datetime.date(2025, 1, 1)\n    &gt;&gt;&gt; Frequency(\"annually\").last_day(date(2025, 11, 21))\n    datetime.date(2025, 12, 31)\n    \"\"\"\n\n    frequency: FrequencyType\n\n    def __init__(self, frequency: FrequencyType) -&gt; None:\n        self.frequency = frequency\n\n    @classmethod\n    def ensure(cls, frequency: \"Frequency|FrequencyType\") -&gt; \"Frequency\":\n        if isinstance(frequency, Frequency):\n            return frequency\n        return cls(frequency)\n\n    def first_day(self, as_of: date) -&gt; date:\n        if self.frequency == \"weekly\":\n            return as_of - timedelta(days=as_of.weekday())\n        elif self.frequency == \"monthly\":\n            return as_of.replace(day=1)\n        elif self.frequency == \"quarterly\":\n            return as_of.replace(day=1, month=((as_of.month - 1) // 3) * 3 + 1)\n        elif self.frequency == \"annually\":\n            return as_of.replace(day=1, month=1)\n        else:\n            raise AssertionError(f\"Invalid frequency: {self.frequency}\")\n\n    def last_day(self, as_of: date) -&gt; date:\n        if self.frequency == \"weekly\":\n            return as_of + timedelta(days=6 - as_of.weekday())\n        elif self.frequency == \"monthly\":\n            return as_of.replace(day=calendar.monthrange(as_of.year, as_of.month)[1])\n        elif self.frequency == \"quarterly\":\n            month = ((as_of.month - 1) // 3) * 3 + 3\n            return as_of.replace(day=calendar.monthrange(as_of.year, month)[1], month=month)\n        elif self.frequency == \"annually\":\n            return as_of.replace(day=31, month=12)\n        else:\n            raise AssertionError(f\"Invalid frequency: {self.frequency}\")\n\n    def min_max_offset(\n        self,\n    ) -&gt; tuple[int, int]:\n        if self.frequency == \"weekly\":\n            return (-7, 7)\n        elif self.frequency == \"monthly\":\n            return (-31, 31)\n        elif self.frequency == \"quarterly\":\n            return (-92, 92)\n        elif self.frequency == \"annually\":\n            return (-366, 366)\n        else:\n            raise AssertionError(f\"Invalid frequency: {self.frequency}\")\n\n    def assert_offset(self, offset: int) -&gt; None:\n        min_offset, max_offset = self.min_max_offset()\n        assert min_offset &lt;= offset &lt; max_offset, (\n            f\"Invalid offset: {offset} for frequency: {self.frequency} expected between {min_offset} and {max_offset}\"\n        )\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.FrequencyOffset","title":"<code>FrequencyOffset</code>","text":"<pre><code>&gt;&gt;&gt; FrequencyOffset(Frequency(\"weekly\"), 0).boundaries(date(2025, 11, 21))\n(datetime.date(2025, 11, 17), datetime.date(2025, 11, 23))\n&gt;&gt;&gt; FrequencyOffset(\"weekly\", 1).boundaries(date(2025, 11, 21))\n(datetime.date(2025, 11, 18), datetime.date(2025, 11, 24))\n&gt;&gt;&gt; FrequencyOffset(Frequency(\"weekly\"), -1).boundaries(date(2025, 11, 21))\n(datetime.date(2025, 11, 16), datetime.date(2025, 11, 22))\n&gt;&gt;&gt; on20thOfMonth = FrequencyOffset(Frequency(\"monthly\"), 19)\n&gt;&gt;&gt; on20thOfMonth.boundaries(date(2025, 11, 21))\n(datetime.date(2025, 11, 20), datetime.date(2025, 12, 19))\n&gt;&gt;&gt; on20thOfMonth.boundaries(on20thOfMonth.boundaries(date(2025, 11, 21))[1]+timedelta(days=1))\n(datetime.date(2025, 12, 20), datetime.date(2026, 1, 19))\n&gt;&gt;&gt; on3rdBeforeEndOfMonth = FrequencyOffset(\"monthly\", -3)\n&gt;&gt;&gt; b1 = on3rdBeforeEndOfMonth.boundaries(date(2025, 11, 21)); b1\n(datetime.date(2025, 10, 29), datetime.date(2025, 11, 27))\n&gt;&gt;&gt; b2 = on3rdBeforeEndOfMonth.boundaries(b1[1]+timedelta(days=1)); b2\n(datetime.date(2025, 11, 28), datetime.date(2025, 12, 28))\n&gt;&gt;&gt; b3 = on3rdBeforeEndOfMonth.boundaries(b2[1]+timedelta(days=1)); b3\n(datetime.date(2025, 12, 29), datetime.date(2026, 1, 28))\n&gt;&gt;&gt; b4 = on3rdBeforeEndOfMonth.boundaries(b3[1]+timedelta(days=1)); b4\n(datetime.date(2026, 1, 29), datetime.date(2026, 2, 25))\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>class FrequencyOffset:\n    \"\"\"\n    &gt;&gt;&gt; FrequencyOffset(Frequency(\"weekly\"), 0).boundaries(date(2025, 11, 21))\n    (datetime.date(2025, 11, 17), datetime.date(2025, 11, 23))\n    &gt;&gt;&gt; FrequencyOffset(\"weekly\", 1).boundaries(date(2025, 11, 21))\n    (datetime.date(2025, 11, 18), datetime.date(2025, 11, 24))\n    &gt;&gt;&gt; FrequencyOffset(Frequency(\"weekly\"), -1).boundaries(date(2025, 11, 21))\n    (datetime.date(2025, 11, 16), datetime.date(2025, 11, 22))\n    &gt;&gt;&gt; on20thOfMonth = FrequencyOffset(Frequency(\"monthly\"), 19)\n    &gt;&gt;&gt; on20thOfMonth.boundaries(date(2025, 11, 21))\n    (datetime.date(2025, 11, 20), datetime.date(2025, 12, 19))\n    &gt;&gt;&gt; on20thOfMonth.boundaries(on20thOfMonth.boundaries(date(2025, 11, 21))[1]+timedelta(days=1))\n    (datetime.date(2025, 12, 20), datetime.date(2026, 1, 19))\n    &gt;&gt;&gt; on3rdBeforeEndOfMonth = FrequencyOffset(\"monthly\", -3)\n    &gt;&gt;&gt; b1 = on3rdBeforeEndOfMonth.boundaries(date(2025, 11, 21)); b1\n    (datetime.date(2025, 10, 29), datetime.date(2025, 11, 27))\n    &gt;&gt;&gt; b2 = on3rdBeforeEndOfMonth.boundaries(b1[1]+timedelta(days=1)); b2\n    (datetime.date(2025, 11, 28), datetime.date(2025, 12, 28))\n    &gt;&gt;&gt; b3 = on3rdBeforeEndOfMonth.boundaries(b2[1]+timedelta(days=1)); b3\n    (datetime.date(2025, 12, 29), datetime.date(2026, 1, 28))\n    &gt;&gt;&gt; b4 = on3rdBeforeEndOfMonth.boundaries(b3[1]+timedelta(days=1)); b4\n    (datetime.date(2026, 1, 29), datetime.date(2026, 2, 25))\n    \"\"\"\n\n    frequency: Frequency\n    offset: int\n\n    def __init__(self, frequency: Frequency | FrequencyType, offset: int) -&gt; None:\n        self.frequency = Frequency.ensure(frequency)\n        self.frequency.assert_offset(offset)\n        self.offset = offset\n\n    def boundaries(self, as_of: date) -&gt; tuple[date, date]:\n        \"\"\"\n        Return the boundaries around the given date (inclusive).\n        \"\"\"\n        if self.offset &gt;= 0:\n            d = self.frequency.first_day(as_of)\n            dd = (\n                self.frequency.first_day(d - timedelta(days=1)),\n                d,\n                self.frequency.last_day(as_of) + timedelta(days=1),\n            )\n            with_delta = [t + timedelta(days=self.offset) for t in dd]\n        else:\n            d = self.frequency.last_day(as_of)\n            dd = (\n                self.frequency.first_day(as_of) - timedelta(days=1),\n                d,\n                self.frequency.last_day(d + timedelta(days=1)),\n            )\n            with_delta = [t + timedelta(days=1 + self.offset) for t in dd]\n\n        assert with_delta[0] &lt;= as_of\n        if as_of &lt; with_delta[1]:\n            return with_delta[0], with_delta[1] - timedelta(days=1)\n        else:\n            assert with_delta[1] &lt;= as_of &lt; with_delta[2]\n            return with_delta[1], with_delta[2] - timedelta(days=1)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.FrequencyOffset.boundaries","title":"<code>boundaries(as_of)</code>","text":"<p>Return the boundaries around the given date (inclusive).</p> Source code in <code>src/lythonic/periodic.py</code> <pre><code>def boundaries(self, as_of: date) -&gt; tuple[date, date]:\n    \"\"\"\n    Return the boundaries around the given date (inclusive).\n    \"\"\"\n    if self.offset &gt;= 0:\n        d = self.frequency.first_day(as_of)\n        dd = (\n            self.frequency.first_day(d - timedelta(days=1)),\n            d,\n            self.frequency.last_day(as_of) + timedelta(days=1),\n        )\n        with_delta = [t + timedelta(days=self.offset) for t in dd]\n    else:\n        d = self.frequency.last_day(as_of)\n        dd = (\n            self.frequency.first_day(as_of) - timedelta(days=1),\n            d,\n            self.frequency.last_day(d + timedelta(days=1)),\n        )\n        with_delta = [t + timedelta(days=1 + self.offset) for t in dd]\n\n    assert with_delta[0] &lt;= as_of\n    if as_of &lt; with_delta[1]:\n        return with_delta[0], with_delta[1] - timedelta(days=1)\n    else:\n        assert with_delta[1] &lt;= as_of &lt; with_delta[2]\n        return with_delta[1], with_delta[2] - timedelta(days=1)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.IntervalUnit","title":"<code>IntervalUnit</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Approximate time interval units expressed in days.</p> <pre><code>&gt;&gt;&gt; for n in \"usmhDWMQY\": print(f\"{n} = {IntervalUnit.from_string(n).timedelta()}\")\nu = 0:00:00.000001\ns = 0:00:01\nm = 0:01:00\nh = 1:00:00\nD = 1 day, 0:00:00\nW = 7 days, 0:00:00\nM = 30 days, 10:30:43.200000\nQ = 91 days, 7:32:09.600000\nY = 365 days, 6:08:38.400000\n&gt;&gt;&gt; [i.name for i in IntervalUnit]\n['u', 's', 'm', 'h', 'D', 'W', 'M', 'Q', 'Y']\n&gt;&gt;&gt; IntervalUnit.minutes\nIntervalUnit.m\n&gt;&gt;&gt; list(IntervalUnit.aliases())\n['microseconds', 'seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'quarters', 'years']\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>class IntervalUnit(Enum):\n    \"\"\"\n    Approximate time interval units expressed in days.\n\n    &gt;&gt;&gt; for n in \"usmhDWMQY\": print(f\"{n} = {IntervalUnit.from_string(n).timedelta()}\")\n    u = 0:00:00.000001\n    s = 0:00:01\n    m = 0:01:00\n    h = 1:00:00\n    D = 1 day, 0:00:00\n    W = 7 days, 0:00:00\n    M = 30 days, 10:30:43.200000\n    Q = 91 days, 7:32:09.600000\n    Y = 365 days, 6:08:38.400000\n    &gt;&gt;&gt; [i.name for i in IntervalUnit]\n    ['u', 's', 'm', 'h', 'D', 'W', 'M', 'Q', 'Y']\n    &gt;&gt;&gt; IntervalUnit.minutes\n    IntervalUnit.m\n    &gt;&gt;&gt; list(IntervalUnit.aliases())\n    ['microseconds', 'seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'quarters', 'years']\n\n    \"\"\"\n\n    u = microseconds = 1 / (1_000_000 * SECONDS_IN_DAY)\n    s = seconds = 1 / SECONDS_IN_DAY\n    m = minutes = 1 / (60 * 24)\n    h = hours = 1 / 24\n    D = days = 1\n    W = weeks = 7\n    M = months = YEAR_IN_DAYS / 12\n    Q = quarters = YEAR_IN_DAYS / 4\n    Y = years = YEAR_IN_DAYS\n\n    @classmethod\n    def from_string(cls, n: str) -&gt; \"IntervalUnit\":\n        return cls[n]\n\n    @classmethod\n    def aliases(cls) -&gt; dict[str, \"IntervalUnit\"]:\n        return {n: e for n, e in cls.__members__.items() if len(n) != 1}\n\n    def timedelta(self) -&gt; timedelta:\n        return timedelta(days=self.value)\n\n    @override\n    def __str__(self) -&gt; str:\n        return self.name\n\n    @override\n    def __repr__(self) -&gt; str:\n        return f\"IntervalUnit.{str(self)}\"\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.Interval","title":"<code>Interval</code>","text":"<p>Mapping years, month, and quarter to real numbers of approximate days. Weeks and days mapped to integer. \"</p> <pre><code>&gt;&gt;&gt; p = lambda i: f\"{i} {i.timedelta()}\"\n&gt;&gt;&gt; p(Interval(2, IntervalUnit.s))\n'2s 0:00:02'\n&gt;&gt;&gt; p(Interval.from_string(\"2s\"))\n'2s 0:00:02'\n&gt;&gt;&gt; p(Interval.from_string(\"2seconds\"))\n'2s 0:00:02'\n&gt;&gt;&gt; p(Interval.from_string(\"2 seconds\"))\n'2s 0:00:02'\n&gt;&gt;&gt; p(Interval.from_string(\"2 second\"))\nTraceback (most recent call last):\n...\nValueError: ('Invalid interval string', '2 second')\n&gt;&gt;&gt; p(Interval(1, IntervalUnit.D))\n'1D 1 day, 0:00:00'\n&gt;&gt;&gt; float(Interval.from_string(\"1D\"))\n1.0\n&gt;&gt;&gt; float(Interval.from_string(\"3h\"))\n0.125\n&gt;&gt;&gt; Interval.from_string(\"1D\") == Interval(1, IntervalUnit.D)\nTrue\n&gt;&gt;&gt; Interval(\"1D\") &gt;= Interval.from_string(\"23 hours\")\nTrue\n&gt;&gt;&gt; Interval(Interval(\"1D\")) &gt;= Interval.from_string(\"24 hours\")\nTrue\n&gt;&gt;&gt; Interval.from_string(\"1D\") &gt;= Interval.from_string(\"25 hours\")\nFalse\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>@final\n@total_ordering\nclass Interval:\n    \"\"\"Mapping years, month, and quarter to real numbers of approximate days. Weeks and days mapped to integer. \"\n\n    &gt;&gt;&gt; p = lambda i: f\"{i} {i.timedelta()}\"\n    &gt;&gt;&gt; p(Interval(2, IntervalUnit.s))\n    '2s 0:00:02'\n    &gt;&gt;&gt; p(Interval.from_string(\"2s\"))\n    '2s 0:00:02'\n    &gt;&gt;&gt; p(Interval.from_string(\"2seconds\"))\n    '2s 0:00:02'\n    &gt;&gt;&gt; p(Interval.from_string(\"2 seconds\"))\n    '2s 0:00:02'\n    &gt;&gt;&gt; p(Interval.from_string(\"2 second\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: ('Invalid interval string', '2 second')\n    &gt;&gt;&gt; p(Interval(1, IntervalUnit.D))\n    '1D 1 day, 0:00:00'\n    &gt;&gt;&gt; float(Interval.from_string(\"1D\"))\n    1.0\n    &gt;&gt;&gt; float(Interval.from_string(\"3h\"))\n    0.125\n    &gt;&gt;&gt; Interval.from_string(\"1D\") == Interval(1, IntervalUnit.D)\n    True\n    &gt;&gt;&gt; Interval(\"1D\") &gt;= Interval.from_string(\"23 hours\")\n    True\n    &gt;&gt;&gt; Interval(Interval(\"1D\")) &gt;= Interval.from_string(\"24 hours\")\n    True\n    &gt;&gt;&gt; Interval.from_string(\"1D\") &gt;= Interval.from_string(\"25 hours\")\n    False\n    \"\"\"\n\n    FREQ_RE = re.compile(f\"(\\\\d+)([{''.join(p.name for p in IntervalUnit)}])\")\n    ALIAS_FREQ_RE = re.compile(f\"(\\\\d+) ?({'|'.join(IntervalUnit.aliases())})\")\n\n    multiplier: int\n    period: IntervalUnit\n\n    def __init__(\n        self, multiplier_or_value: \"int|str|Interval\", period: IntervalUnit | None = None\n    ) -&gt; None:\n        if isinstance(multiplier_or_value, int):\n            assert period is not None\n            self.multiplier = multiplier_or_value\n            self.period = period\n        else:\n            if isinstance(multiplier_or_value, str):\n                multiplier_or_value = Interval.from_string(multiplier_or_value)\n            self.multiplier = multiplier_or_value.multiplier\n            self.period = multiplier_or_value.period\n\n    @classmethod\n    def from_string_safe(cls, s: \"Interval|str|None\") -&gt; \"Interval | None\":\n        if s is None:\n            return None\n        if isinstance(s, Interval):\n            return s\n        return cls.from_string(s)\n\n    @classmethod\n    def from_string(cls, s: str) -&gt; \"Interval\":\n        m = cls.matcher(s)\n        if m:\n            n, p = m.groups()\n            return cls(int(n), IntervalUnit.from_string(p))\n        else:\n            raise ValueError(\"Invalid interval string\", s)\n\n    @classmethod\n    def matcher(cls, s: str) -&gt; re.Match[str] | None:\n        return re.match(cls.FREQ_RE, s) or re.match(cls.ALIAS_FREQ_RE, s)\n\n    def timedelta(self) -&gt; timedelta:\n        return self.multiplier * self.period.timedelta()\n\n    def __float__(self) -&gt; float:\n        \"\"\"Interval duration in days\"\"\"\n        return float(self.multiplier * self.period.value)\n\n    @override\n    def __hash__(self):\n        return hash((self.multiplier, self.period))\n\n    @override\n    def __eq__(self, other: object) -&gt; bool:\n        assert isinstance(other, Interval)\n        return self.timedelta() == other.timedelta()\n\n    def __lt__(self, other: object) -&gt; bool:\n        assert isinstance(other, Interval)\n        return self.timedelta() &lt; other.timedelta()\n\n    def match(self, d: date | datetime, as_of: date | datetime) -&gt; bool:\n        return d &lt;= as_of and d + self.timedelta() &gt; as_of\n\n    def find_file(\n        self,\n        path: Path,\n        as_of: date | datetime,\n        suffix: str = \".csv\",\n    ) -&gt; Path | None:\n        ff = list(\n            reversed(\n                sorted(\n                    (date_from_name(f.name), f)\n                    for f in path.glob(f\"*{suffix}\")\n                    if re.match(r\"^\\d{8}\", f.name[:8])\n                )\n            )\n        )\n        for d, f in ff:\n            if d &lt;= as_of:\n                if self.match(d, as_of):\n                    return f\n                else:\n                    break\n        return None\n\n    @override\n    def __str__(self) -&gt; str:\n        return f\"{self.multiplier}{self.period}\"\n\n    @override\n    def __repr__(self) -&gt; str:\n        return f\"Interval({self.multiplier}, {self.period!r})\"\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.Interval.__float__","title":"<code>__float__()</code>","text":"<p>Interval duration in days</p> Source code in <code>src/lythonic/periodic.py</code> <pre><code>def __float__(self) -&gt; float:\n    \"\"\"Interval duration in days\"\"\"\n    return float(self.multiplier * self.period.value)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.Moment","title":"<code>Moment</code>","text":"<pre><code>&gt;&gt;&gt; m = Moment.start()\n&gt;&gt;&gt; m = m.capture(\"instant\")\n&gt;&gt;&gt; tt.sleep(1)\n&gt;&gt;&gt; m = m.capture(\"a second\")\n&gt;&gt;&gt; s = m.chain()\n&gt;&gt;&gt; s.startswith('[start] 0.0'), 's-&gt; [instant] 1.' in s , s.endswith('s-&gt; [a second]')\n(True, True, True)\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>class Moment:\n    \"\"\"\n    &gt;&gt;&gt; m = Moment.start()\n    &gt;&gt;&gt; m = m.capture(\"instant\")\n    &gt;&gt;&gt; tt.sleep(1)\n    &gt;&gt;&gt; m = m.capture(\"a second\")\n    &gt;&gt;&gt; s = m.chain()\n    &gt;&gt;&gt; s.startswith('[start] 0.0'), 's-&gt; [instant] 1.' in s , s.endswith('s-&gt; [a second]')\n    (True, True, True)\n    \"\"\"\n\n    time: float\n    name: str\n    prev: \"Moment | None\"\n\n    def __init__(self, name: str, prev: \"Moment | None\" = None) -&gt; None:\n        self.time = tt.time()\n        self.name = name\n        self.prev = prev\n\n    @staticmethod\n    def start():\n        \"\"\"capture the starting moment\"\"\"\n        return Moment(\"start\")\n\n    def capture(self, name: str):\n        \"\"\"capture the named moment relative to this one\"\"\"\n        return Moment(name, self)\n\n    def elapsed(self):\n        \"\"\"return time in seconds since previous moment\"\"\"\n        if self.prev is None:\n            return 0\n        return self.time - self.prev.time\n\n    @override\n    def __str__(self):\n        return (\n            f\" {self.elapsed():.3f}s-&gt; [{self.name}]\" if self.prev is not None else f\"[{self.name}]\"\n        )\n\n    def chain(self) -&gt; str:\n        return str(self) if self.prev is None else self.prev.chain() + str(self)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.Moment.start","title":"<code>start()</code>  <code>staticmethod</code>","text":"<p>capture the starting moment</p> Source code in <code>src/lythonic/periodic.py</code> <pre><code>@staticmethod\ndef start():\n    \"\"\"capture the starting moment\"\"\"\n    return Moment(\"start\")\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.Moment.capture","title":"<code>capture(name)</code>","text":"<p>capture the named moment relative to this one</p> Source code in <code>src/lythonic/periodic.py</code> <pre><code>def capture(self, name: str):\n    \"\"\"capture the named moment relative to this one\"\"\"\n    return Moment(name, self)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.Moment.elapsed","title":"<code>elapsed()</code>","text":"<p>return time in seconds since previous moment</p> Source code in <code>src/lythonic/periodic.py</code> <pre><code>def elapsed(self):\n    \"\"\"return time in seconds since previous moment\"\"\"\n    if self.prev is None:\n        return 0\n    return self.time - self.prev.time\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.PeriodicTask","title":"<code>PeriodicTask</code>","text":"<p>A task that runs at a specified frequency in seconds.</p> <p>Use with <code>run_all()</code> to execute multiple tasks in an async event loop.</p> Source code in <code>src/lythonic/periodic.py</code> <pre><code>class PeriodicTask:\n    \"\"\"\n    A task that runs at a specified frequency in seconds.\n\n    Use with `run_all()` to execute multiple tasks in an async event loop.\n    \"\"\"\n\n    freq: int\n    logic: Callable[[], Any]\n    last_run: float | None = None\n\n    def __init__(self, freq: int, logic: Callable[[], Any]) -&gt; None:\n        self.freq = freq\n        self.logic = logic\n\n    def is_due(self):\n        return self.last_run is None or stime.time() - self.last_run &gt; self.freq\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.run_all","title":"<code>run_all(*tasks, shutdown_event=None, collect_results=_collect_nothing)</code>  <code>async</code>","text":"<p>Run multiple periodic tasks in an async loop.</p> <p>Tasks are scheduled based on their <code>freq</code> (in seconds). The loop tick interval is the GCD of all task frequencies for efficiency. Set <code>shutdown_event</code> to signal graceful termination.</p> Source code in <code>src/lythonic/periodic.py</code> <pre><code>async def run_all(\n    *tasks: PeriodicTask,\n    shutdown_event: asyncio.Event | None = None,\n    collect_results: Callable[[str, Any], None] = _collect_nothing,\n):\n    \"\"\"\n    Run multiple periodic tasks in an async loop.\n\n    Tasks are scheduled based on their `freq` (in seconds). The loop tick interval\n    is the GCD of all task frequencies for efficiency. Set `shutdown_event` to\n    signal graceful termination.\n    \"\"\"\n    if shutdown_event is None:\n        shutdown_event = asyncio.Event()\n    if len(tasks) == 0:\n        log.warning(\"No tasks to run\")\n        return\n    tick = gcd(*[t.freq for t in tasks])\n    loop = asyncio.get_running_loop()\n\n    while True:\n        start = stime.time()\n        for t in tasks:\n            if t.is_due():\n                t.last_run = start\n\n                try:\n                    if inspect.iscoroutinefunction(t.logic):\n                        r = await t.logic()\n                    else:\n                        r = await loop.run_in_executor(None, t.logic)\n                except (Exception, asyncio.CancelledError) as _:\n                    r = sys.exc_info()\n                collect_results(t.logic.__name__, r)\n            if shutdown_event.is_set():\n                return\n        elapsed = stime.time() - start\n        await asyncio.sleep(tick - elapsed if elapsed &lt; tick else 0)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.dt_to_bytes","title":"<code>dt_to_bytes(dt)</code>","text":"<p>Convert datetime to bytes</p> <pre><code>&gt;&gt;&gt; dt_to_bytes(datetime( 1900,1,1,0,0,0))\nb'\\xff\\xf8&amp;\\xef\\xb7C`\\x00'\n&gt;&gt;&gt; dt_to_bytes(datetime( 2000,1,1,0,0,0))\nb'\\x00\\x03]\\x01;7\\xe0\\x00'\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>def dt_to_bytes(dt: datetime) -&gt; bytes:\n    \"\"\"\n    Convert datetime to bytes\n\n    &gt;&gt;&gt; dt_to_bytes(datetime( 1900,1,1,0,0,0))\n    b'\\\\xff\\\\xf8&amp;\\\\xef\\\\xb7C`\\\\x00'\n    &gt;&gt;&gt; dt_to_bytes(datetime( 2000,1,1,0,0,0))\n    b'\\\\x00\\\\x03]\\\\x01;7\\\\xe0\\\\x00'\n    \"\"\"\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=UTC)\n    mics = total_microseconds(dt - EPOCH_ZERO)\n    return mics.to_bytes(8, \"big\", signed=True)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.dt_from_bytes","title":"<code>dt_from_bytes(b)</code>","text":"<p>Convert  bytes to datetime</p> <pre><code>&gt;&gt;&gt; dt_from_bytes(b'\\xff\\xf8&amp;\\xef\\xb7C`\\x00')\ndatetime.datetime(1900, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; dt_from_bytes(b'\\x00\\x03]\\x01;7\\xe0\\x00')\ndatetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>def dt_from_bytes(b: bytes) -&gt; datetime:\n    \"\"\"\n    Convert  bytes to datetime\n\n    &gt;&gt;&gt; dt_from_bytes(b'\\\\xff\\\\xf8&amp;\\\\xef\\\\xb7C`\\\\x00')\n    datetime.datetime(1900, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)\n    &gt;&gt;&gt; dt_from_bytes(b'\\\\x00\\\\x03]\\\\x01;7\\\\xe0\\\\x00')\n    datetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)\n    \"\"\"\n    mics = int.from_bytes(b, \"big\", signed=True)\n    return EPOCH_ZERO + timedelta(microseconds=mics)\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.date_from_name","title":"<code>date_from_name(s)</code>","text":"Source code in <code>src/lythonic/periodic.py</code> <pre><code>def date_from_name(s: str) -&gt; date:\n    return date(int(s[:4]), int(s[4:6]), int(s[6:8]))\n</code></pre>"},{"location":"reference/periodic/#lythonic.periodic.adjust_as_of_date","title":"<code>adjust_as_of_date(as_of_date)</code>","text":"<pre><code>&gt;&gt;&gt; adjust_as_of_date(None) == date.today()\nTrue\n&gt;&gt;&gt; adjust_as_of_date(date(2021, 1, 1)) == date(2021, 1, 1)\nTrue\n</code></pre> Source code in <code>src/lythonic/periodic.py</code> <pre><code>def adjust_as_of_date(as_of_date: date | None) -&gt; date:\n    \"\"\"\n    &gt;&gt;&gt; adjust_as_of_date(None) == date.today()\n    True\n    &gt;&gt;&gt; adjust_as_of_date(date(2021, 1, 1)) == date(2021, 1, 1)\n    True\n    \"\"\"\n    return date.today() if as_of_date is None else as_of_date\n</code></pre>"},{"location":"reference/state/","title":"lythonic.state","text":"<p>Core module for SQLite ORM functionality.</p> <p>Lightweight SQLite ORM with Pydantic-based schema definition.</p> <p>This module provides a simple ORM-like interface for SQLite databases using Pydantic models to define the schema. It supports automatic DDL generation, CRUD operations, type mapping, and multi-tenant access patterns.</p>"},{"location":"reference/state/#lythonic.state--quick-start","title":"Quick Start","text":"<p>Define your models by subclassing <code>DbModel</code>:</p> <pre><code>from pydantic import Field\nfrom lythonic.state import DbModel, Schema, open_sqlite_db\n\nclass Author(DbModel[\"Author\"]):\n    author_id: int = Field(default=-1, description=\"(PK)\")\n    name: str = Field(description=\"Author name\")\n\nclass Book(DbModel[\"Book\"]):\n    book_id: int = Field(default=-1, description=\"(PK)\")\n    author_id: int = Field(description=\"(FK:Author.author_id)\")\n    title: str\n    year: int | None = None\n\nSCHEMA = Schema([Author, Book])\n</code></pre> <p>Create tables and use CRUD operations:</p> <pre><code>SCHEMA.create_schema(Path(\"books.db\"))\n\nwith open_sqlite_db(\"books.db\") as conn:\n    author = Author(name=\"Jane Austen\")\n    author.save(conn)  # Inserts with auto-increment, sets author_id\n\n    book = Book(author_id=author.author_id, title=\"Pride and Prejudice\", year=1813)\n    book.save(conn)\n\n    # Query\n    books = Book.select(conn, author_id=author.author_id)\n    loaded = Book.load_by_id(conn, book.book_id)\n    conn.commit()\n</code></pre>"},{"location":"reference/state/#lythonic.state--schema-definition","title":"Schema Definition","text":""},{"location":"reference/state/#lythonic.state--primary-keys","title":"Primary Keys","text":"<p>Mark a field as primary key by adding <code>(PK)</code> at the start of the description:</p> <pre><code>user_id: int = Field(default=-1, description=\"(PK) Unique user identifier\")\n</code></pre> <p>When <code>save()</code> is called on a model with <code>pk_field=-1</code>, it auto-increments.</p>"},{"location":"reference/state/#lythonic.state--foreign-keys","title":"Foreign Keys","text":"<p>Mark foreign keys with <code>(FK:Table.field)</code>:</p> <pre><code>author_id: int = Field(description=\"(FK:Author.author_id) Reference to author\")\n</code></pre>"},{"location":"reference/state/#lythonic.state--nullable-fields","title":"Nullable Fields","text":"<p>Use <code>| None</code> union type:</p> <pre><code>email: str | None = Field(default=None, description=\"Optional email\")\n</code></pre>"},{"location":"reference/state/#lythonic.state--enum-and-literal-constraints","title":"Enum and Literal Constraints","text":"<p>Enum and Literal types generate CHECK constraints:</p> <pre><code>from typing import Literal\n\nstatus: Literal[\"active\", \"inactive\", \"pending\"]\n</code></pre> <p>Generates: <code>status TEXT NOT NULL CHECK (status IN ('active', 'inactive', 'pending'))</code></p>"},{"location":"reference/state/#lythonic.state--supported-types","title":"Supported Types","text":"<p>The following Python types are automatically mapped to SQLite:</p> Python Type SQLite Type Notes int, bool INTEGER bool stored as 0/1 float REAL str TEXT bytes BLOB datetime TEXT Stored as ISO format string date TEXT Stored as ISO format string Path TEXT Stored as string path Enum TEXT Stored as enum value IntEnum INTEGER BaseModel TEXT Stored as JSON string JsonBase TEXT Stored as JSON with type info"},{"location":"reference/state/#lythonic.state--crud-operations","title":"CRUD Operations","text":""},{"location":"reference/state/#lythonic.state--insert","title":"Insert","text":"<pre><code>record = MyModel(field1=\"value\")\nrecord.insert(conn, auto_increment=True)  # Sets PK from lastrowid\n</code></pre>"},{"location":"reference/state/#lythonic.state--save-upsert","title":"Save (Upsert)","text":"<pre><code>record.save(conn)  # Inserts if pk=-1, else updates existing row\n</code></pre>"},{"location":"reference/state/#lythonic.state--select","title":"Select","text":"<pre><code># Select all\nall_records = MyModel.select(conn)\n\n# Filter by field value\nfiltered = MyModel.select(conn, status=\"active\")\n\n# Filter with operators: eq, ne, gt, lt, gte, lte\nrecent = MyModel.select(conn, gt__year=2020)\n\n# IN clause (pass a list)\nspecific = MyModel.select(conn, status=[\"active\", \"pending\"])\n</code></pre>"},{"location":"reference/state/#lythonic.state--load-by-id","title":"Load by ID","text":"<pre><code>record = MyModel.load_by_id(conn, 42)  # Returns None if not found\n</code></pre>"},{"location":"reference/state/#lythonic.state--update","title":"Update","text":"<pre><code>record.field = \"new value\"\nn_updated = record.update(conn, pk_field=record.pk_field)\n</code></pre>"},{"location":"reference/state/#lythonic.state--delete","title":"Delete","text":"<pre><code># Delete all matching rows, returns count of deleted rows\nn_deleted = MyModel.delete(conn, status=\"inactive\")\n</code></pre>"},{"location":"reference/state/#lythonic.state--primary-key-filter","title":"Primary Key Filter","text":"<p>Use <code>get_pk_filter()</code> to get a filter dict for the current record's primary key:</p> <pre><code>record = MyModel.load_by_id(conn, 42)\npk_filter, pk_defined = record.get_pk_filter()\n# pk_filter is e.g. {\"my_id\": 42}, pk_defined is True if pk != -1\n\n# Useful for deleting related records\nRelatedModel.delete(conn, **pk_filter)\n</code></pre>"},{"location":"reference/state/#lythonic.state--count-and-exists","title":"Count and Exists","text":"<pre><code>count = MyModel.select_count(conn, status=\"active\")\nexists = MyModel.exists(conn, email=\"user@example.com\")\n</code></pre>"},{"location":"reference/state/#lythonic.state--multi-model-queries","title":"Multi-Model Queries","text":"<p>For joins, use <code>from_multi_model_row()</code>:</p> <pre><code>from lythonic.state import execute_sql, from_multi_model_row\n\ncursor = conn.cursor()\nexecute_sql(\n    cursor,\n    f\"SELECT {Author.columns('a')}, {Book.columns('b')} \"\n    f\"FROM {Author.alias('a')}, {Book.alias('b')} \"\n    \"WHERE a.author_id = b.author_id\"\n)\nfor row in cursor.fetchall():\n    author, book = from_multi_model_row(row, [Author, Book])\n</code></pre>"},{"location":"reference/state/#lythonic.state--multi-tenant-support-userowned","title":"Multi-Tenant Support (UserOwned)","text":"<p>For multi-tenant applications, use <code>UserOwned</code> base class (from <code>lythonic.state.user</code>):</p> <pre><code>from lythonic.state.user import User, UserOwned, UserContext\n\nclass Task(UserOwned[\"Task\"]):\n    task_id: int = Field(default=-1, description=\"(PK)\")\n    title: str\n\n# All operations require a UserContext\nuser_ctx = UserContext(user=current_user)\ntask = Task(title=\"My Task\")\ntask.save_with_ctx(user_ctx, conn)  # Automatically sets user_id\n\n# Queries are automatically scoped to user\ntasks = Task.select(conn, user_ctx=user_ctx)\ntask = Task.load_by_id_with_ctx(conn, user_ctx, task_id=42)\n</code></pre>"},{"location":"reference/state/#lythonic.state--schema-management","title":"Schema Management","text":"<pre><code>from lythonic.state import Schema, DbFile\n\nSCHEMA = Schema([User, Task, Event])\n\n# Create tables directly\nSCHEMA.create_schema(Path(\"app.db\"))\n\n# Or use DbFile for lifecycle management\ndb = DbFile(\"app.db\", SCHEMA)\ndb.check(ensure=True)  # Creates tables if missing\n\nwith db.open() as conn:\n    # Use connection\n    pass\n</code></pre>"},{"location":"reference/state/#lythonic.state--exports","title":"Exports","text":"<ul> <li><code>DbModel</code>: Base class for database models</li> <li><code>Schema</code>: Collection of DbModel classes</li> <li><code>DbFile</code>: Database file manager</li> <li><code>FieldInfo</code>: Field metadata extraction</li> <li><code>open_sqlite_db</code>: Context manager for SQLite connections</li> <li><code>execute_sql</code>: Execute SQL with logging</li> <li><code>from_multi_model_row</code>: Parse multi-model query results</li> <li><code>to_sql_datetime</code>: Convert datetime to SQL string</li> </ul>"},{"location":"reference/state/#lythonic.state.DbModel","title":"<code>DbModel</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>class DbModel(BaseModel, Generic[T]):\n    @classmethod\n    def get_table_name(cls: type) -&gt; str:\n        return cls.__name__\n\n    @classmethod\n    def alias(cls, alias: str) -&gt; str:\n        return f\"{cls.get_table_name()} as {alias}\"\n\n    @classmethod\n    def columns(cls, alias: str | None = None) -&gt; str:\n        alias = \"\" if alias is None else f\"{alias}.\"\n        return \", \".join([f\"{alias}{c.name}\" for c in cls.get_field_infos()])\n\n    @classmethod\n    def get_field_infos(\n        cls, filter: Callable[[FieldInfo], bool] = lambda _: True\n    ) -&gt; Generator[FieldInfo, None, None]:\n        for field_name, field_info in cls.model_fields.items():\n            fi = FieldInfo.build(field_name, field_info)\n            if filter(fi):\n                yield fi\n\n    @classmethod\n    def get_field_map(cls) -&gt; dict[str, FieldInfo]:\n        return {fi.name: fi for fi in cls.get_field_infos()}\n\n    @classmethod\n    def create_ddl(cls) -&gt; str:\n        fields: list[str] = []\n        for fi in cls.get_field_infos():\n            type_name = (\n                f\"{fi.ktype.db_type_info.name}{'' if fi.primary_key or fi.nullable else ' NOT NULL'}\"\n                + f\"{' PRIMARY KEY' if fi.primary_key else ''}\"\n                + (\n                    f\" REFERENCES {fi.foreign_key[0]}({fi.foreign_key[1]})\"\n                    if fi.foreign_key\n                    else \"\"\n                )\n                + fi.check_constraint_ddl()\n            )\n            fields.append(f\"{fi.name} {type_name}\")\n\n        return f\"CREATE TABLE {cls.get_table_name()} (\" + \", \".join(fields) + \")\"\n\n    def insert(self, conn: sqlite3.Connection, auto_increment: bool = False):\n        cursor = conn.cursor()\n        cls = self.__class__\n        fields = self._choose_fields(lambda fi: not auto_increment or not fi.primary_key)\n        execute_sql(\n            cursor,\n            f\"INSERT INTO {cls.get_table_name()} ({', '.join(map(lambda fi: fi.name, fields))}) \"\n            + f\"VALUES ({', '.join(['?'] * len(fields))})\",\n            [fi.to_sql_value(self) for fi in fields],\n        )\n        if auto_increment:\n            pks = list(cls.get_field_infos(lambda fi: fi.primary_key))\n            assert len(pks) == 1\n            pks[0].set_value(self, cursor.lastrowid)\n\n    @classmethod\n    def _choose_fields(cls, lambda_filter: Callable[[FieldInfo], bool]) -&gt; list[FieldInfo]:\n        return list(cls.get_field_infos(lambda_filter))\n\n    @classmethod\n    def _ensure_pk(cls) -&gt; FieldInfo:\n        pks = cls._choose_fields(lambda fi: fi.primary_key)\n        assert len(pks) == 1\n        return pks[0]\n\n    def get_pk_filter(self) -&gt; tuple[dict[str, Any], bool]:\n        \"\"\"\n        Returns: primary key filter and whether it is defined\n        \"\"\"\n        cls = self.__class__\n        pk = cls._ensure_pk()\n        pk_val = getattr(self, pk.name)\n        return {pk.name: pk_val}, pk_val != -1\n\n    def save(self, conn: sqlite3.Connection) -&gt; Self:\n        pk_filter, pk_defined = self.get_pk_filter()\n        if not pk_defined:\n            self.insert(conn, auto_increment=True)\n            return self\n        n_updated = self.update(conn, **pk_filter)\n        if n_updated == 0:\n            self.insert(conn)\n        else:\n            assert n_updated == 1\n        return self\n\n    class _WhereBased(NamedTuple):\n        cursor: sqlite3.Cursor\n        table_name: str\n        field_map: dict[str, FieldInfo]\n        where_keys: set[str]\n        where_clauses: list[str]\n        args: list[Any]\n\n        def fields(self) -&gt; list[FieldInfo]:\n            return list(self.field_map.values())\n\n        def where_clause(self) -&gt; str:\n            return (\n                f\"WHERE {' AND '.join(self.where_clauses)}\" if len(self.where_clauses) &gt; 0 else \"\"\n            )\n\n        def execute_select(self, select_vars: str | None = None):\n            if select_vars is None:\n                select_vars = \", \".join([fi.name for fi in self.fields()])\n            execute_sql(\n                self.cursor,\n                f\"SELECT {select_vars} FROM {self.table_name} {self.where_clause()}\",\n                self.args,\n            )\n\n        def execute_delete(self):\n            execute_sql(\n                self.cursor,\n                f\"DELETE FROM {self.table_name} {self.where_clause()}\",\n                self.args,\n            )\n\n    @classmethod\n    def _prepare_where(cls, conn: sqlite3.Connection, **filters: Any) -&gt; _WhereBased:\n        \"\"\"Select all rows from the database that match the filters.\n\n        Filters are given as keyword arguments, the keys are the field names\n        and the values are the values to filter by.\n        \"\"\"\n        field_map: dict[str, FieldInfo] = cls.get_field_map()\n        filter_ops: dict[FilterOp, Any] = {FilterOp.parse(k): v for k, v in filters.items()}\n        unknown_filters = {k: filter_ops[k] for k in filter_ops if k.name not in field_map}\n        assert len(unknown_filters) == 0, (\n            f\"Known fields: {field_map.keys()}, but unknown filters: {unknown_filters}\"\n        )\n        cursor = conn.cursor()\n        args: list[Any] = []\n        where_clauses: list[str] = []\n        where_keys: set[str] = set()\n        for f_op, v in filter_ops.items():\n            fi = field_map[f_op.name]\n            where_keys.add(f_op.name)\n            if f_op.operator == \"eq\":\n                if isinstance(v, list):\n                    v_list: list[Any] = [fi.ktype.db.map_to(val) for val in cast(list[Any], v)]\n                    where_clauses.append(f\"{f_op.name} IN ({', '.join('?' * len(v_list))})\")\n                    args.extend(v_list)\n                else:\n                    where_clauses.append(f\"{f_op.name} = ?\")\n                    args.append(fi.ktype.db.map_to(v))\n            else:\n                op_resolved = FILTER_OPERATOR_SQL[f_op.operator]\n                where_clauses.append(f\"{f_op.name} {op_resolved} ?\")\n                args.append(fi.ktype.db.map_to(v))\n\n        return cls._WhereBased(\n            cursor, cls.get_table_name(), field_map, where_keys, where_clauses, args\n        )\n\n    def update(self, conn: sqlite3.Connection, **filters: Any) -&gt; int:\n        cls = self.__class__\n        sc = cls._prepare_where(conn, **filters)\n        rest_of_the_fields = cls._choose_fields(lambda fi: fi.name not in sc.where_keys)\n        execute_sql(\n            sc.cursor,\n            f\"UPDATE {cls.get_table_name()} \"\n            + f\"SET {', '.join([f'{fi.name} = ?' for fi in rest_of_the_fields])} \"\n            + sc.where_clause(),\n            [fi.to_sql_value(self) for fi in rest_of_the_fields] + sc.args,\n        )\n        return sc.cursor.rowcount\n\n    @classmethod\n    def select(cls, conn: sqlite3.Connection, **filters: Any) -&gt; list[T]:\n        \"\"\"Select all rows from the table that match the filters.\n\n        Filters are given as keyword arguments, the keys are the field names\n        and the values are the values to filter by.\n        \"\"\"\n        sc = cls._prepare_where(conn, **filters)\n        sc.execute_select()\n        return [cls._from_row(row, sc.fields()) for row in sc.cursor.fetchall()]\n\n    @classmethod\n    def delete(cls, conn: sqlite3.Connection, **filters: Any) -&gt; int:\n        \"\"\"Delete all rows from the table that match the filters.\n\n        Filters are given as keyword arguments, the keys are the field names\n        and the values are the values to filter by.\n        \"\"\"\n        sc = cls._prepare_where(conn, **filters)\n        sc.execute_delete()\n        return sc.cursor.rowcount\n\n    @classmethod\n    def _from_row(cls, row: tuple[Any, ...], fields: list[FieldInfo]) -&gt; T:\n        assert len(row) == len(fields)\n        return cast(\n            T,\n            cls.model_validate({fi.name: fi.from_sql_value(row[i]) for i, fi in enumerate(fields)}),\n        )\n\n    @classmethod\n    def select_count(cls, conn: sqlite3.Connection, **filters: Any) -&gt; int:\n        sc = cls._prepare_where(conn, **filters)\n        sc.execute_select(\"COUNT(*)\")\n        return sc.cursor.fetchone()[0]\n\n    @classmethod\n    def exists(cls, conn: sqlite3.Connection, **filters: Any) -&gt; bool:\n        return cls.select_count(conn, **filters) &gt; 0\n\n    @classmethod\n    def load_by_id(cls: type[T], conn: sqlite3.Connection, id: int) -&gt; T | None:\n        rr: list[T] = cls.select(conn, **{cls._ensure_pk().name: id})\n        assert len(rr) &lt;= 1\n        return rr[0] if rr else None\n</code></pre>"},{"location":"reference/state/#lythonic.state.DbModel.get_pk_filter","title":"<code>get_pk_filter()</code>","text":"<p>Returns: primary key filter and whether it is defined</p> Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>def get_pk_filter(self) -&gt; tuple[dict[str, Any], bool]:\n    \"\"\"\n    Returns: primary key filter and whether it is defined\n    \"\"\"\n    cls = self.__class__\n    pk = cls._ensure_pk()\n    pk_val = getattr(self, pk.name)\n    return {pk.name: pk_val}, pk_val != -1\n</code></pre>"},{"location":"reference/state/#lythonic.state.DbModel.select","title":"<code>select(conn, **filters)</code>  <code>classmethod</code>","text":"<p>Select all rows from the table that match the filters.</p> <p>Filters are given as keyword arguments, the keys are the field names and the values are the values to filter by.</p> Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>@classmethod\ndef select(cls, conn: sqlite3.Connection, **filters: Any) -&gt; list[T]:\n    \"\"\"Select all rows from the table that match the filters.\n\n    Filters are given as keyword arguments, the keys are the field names\n    and the values are the values to filter by.\n    \"\"\"\n    sc = cls._prepare_where(conn, **filters)\n    sc.execute_select()\n    return [cls._from_row(row, sc.fields()) for row in sc.cursor.fetchall()]\n</code></pre>"},{"location":"reference/state/#lythonic.state.DbModel.delete","title":"<code>delete(conn, **filters)</code>  <code>classmethod</code>","text":"<p>Delete all rows from the table that match the filters.</p> <p>Filters are given as keyword arguments, the keys are the field names and the values are the values to filter by.</p> Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>@classmethod\ndef delete(cls, conn: sqlite3.Connection, **filters: Any) -&gt; int:\n    \"\"\"Delete all rows from the table that match the filters.\n\n    Filters are given as keyword arguments, the keys are the field names\n    and the values are the values to filter by.\n    \"\"\"\n    sc = cls._prepare_where(conn, **filters)\n    sc.execute_delete()\n    return sc.cursor.rowcount\n</code></pre>"},{"location":"reference/state/#lythonic.state.Schema","title":"<code>Schema</code>","text":"Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>class Schema:\n    tables: list[type[DbModel[Any]]]\n\n    def __init__(self, tables: list[type[DbModel[Any]]]):\n        self.tables = tables\n\n    def check_all_tables_exist(self, conn: sqlite3.Connection):\n        cursor = conn.cursor()\n        execute_sql(cursor, \"SELECT name FROM sqlite_master WHERE type='table' \")\n        all_tables = set(r[0] for r in cursor.fetchall())\n        return all(t.get_table_name() in all_tables for t in self.tables)\n\n    def create_tables(self, conn: sqlite3.Connection):\n        cursor = conn.cursor()\n        for table in self.tables:\n            execute_sql(cursor, table.create_ddl())\n        conn.commit()\n\n    def create_schema(self, path: Path):\n        with open_sqlite_db(path) as conn:\n            self.create_tables(conn)\n</code></pre>"},{"location":"reference/state/#lythonic.state.DbFile","title":"<code>DbFile</code>","text":"Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>class DbFile:\n    path: Path\n    schema: Schema\n\n    def __init__(self, db_path: Path | str, schema: Schema) -&gt; None:\n        self.path = Path(db_path)\n        self.schema = schema\n\n    def check(self, ensure: bool = False) -&gt; bool:\n        if not self.path.exists():\n            if ensure:\n                with self.open() as conn:\n                    self.schema.create_tables(conn)\n                return True\n            return False\n        else:\n            # TODO : migrate db if necessary\n            with self.open() as conn:\n                if not self.schema.check_all_tables_exist(conn):\n                    if not ensure:\n                        return False\n                    self.schema.create_tables(conn)\n            return True\n        return False\n\n    def open(self):\n        return open_sqlite_db(self.path)\n</code></pre>"},{"location":"reference/state/#lythonic.state.FieldInfo","title":"<code>FieldInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>class FieldInfo(NamedTuple):\n    name: str\n    ktype: KnownType\n    description: str\n    nullable: bool\n    primary_key: bool\n    foreign_key: tuple[str, str] | None\n    fixed_choices: list[Any] | None  # For enum types and literal types\n\n    @classmethod\n    def build(cls, name: str, field_info: Any) -&gt; \"FieldInfo\":\n        assert field_info.annotation is not None, f\"Field {name} has no annotation\"\n        ann = field_info.annotation\n        type_: type[Any]\n        fixed_choices: list[Any] | None = None\n        if isinstance(ann, type):\n            type_ = ann\n            is_nullable = False\n        else:\n            origin = get_origin(ann)\n            if origin is UnionType:\n                args = get_args(ann)\n                nones = [arg for arg in args if arg is NoneType]\n                valid_types = [arg for arg in args if arg is not NoneType]\n                assert len(valid_types) == 1 and len(nones) == 1, (\n                    f\"Union {ann} must have exactly 2 types and one of them must be None\"\n                )\n                type_ = valid_types[0]\n                is_nullable = True\n            elif origin is Literal:\n                args = get_args(ann)\n                nones = [arg is NoneType or arg is None for arg in args]\n                fixed_choices = [a for a, n in zip(args, nones, strict=True) if not n]\n                is_nullable = any(nones)\n                types: set[type[Any]] = {type(c) for c in fixed_choices}\n                assert len(types) == 1, f\"Literal {ann} must have only one type\"\n                type_ = types.pop()\n            else:\n                raise AssertionError(f\"Unknown field annotation type: {ann}\")\n\n        if issubclass(type_, Enum):\n            fixed_choices = list(type_)\n\n        description = field_info.description or \"\"\n        is_primary_key = description.startswith(\"(PK)\")\n        if is_primary_key:\n            description = description[4:].strip()\n        assert not (is_primary_key and is_nullable), (\n            \"A field cannot be both a primary key and nullable\"\n        )\n\n        is_foreign_key = description.startswith(\"(FK:\")\n        if is_foreign_key:\n            x, description = description[4:].strip().split(\")\")\n            table_name, field_name = x.split(\".\")\n            foreign_key = table_name, field_name\n        else:\n            foreign_key = None\n\n        return cls(\n            name=name,\n            ktype=KnownType.ensure(type_),\n            description=description,\n            nullable=is_nullable,\n            primary_key=is_primary_key,\n            foreign_key=foreign_key,\n            fixed_choices=fixed_choices,\n        )\n\n    def check_constraint_ddl(self) -&gt; str:\n        if self.fixed_choices is not None:\n            return f\" CHECK ({self.name} IN ({', '.join([repr(self.ktype.db.map_to(c)) for c in self.fixed_choices])}))\"\n        return \"\"\n\n    def to_sql_value(self, o: \"DbModel[T]\") -&gt; Any:\n        v = getattr(o, self.name)\n        return self.ktype.db.map_to(v)\n\n    def from_sql_value(self, v: Any) -&gt; Any:\n        return self.ktype.db.map_from(v)\n\n    def set_value(self, o: \"DbModel[T]\", v: Any):\n        setattr(o, self.name, self.from_sql_value(v))\n</code></pre>"},{"location":"reference/state/#lythonic.state.open_sqlite_db","title":"<code>open_sqlite_db(db_name)</code>","text":"<p>Open or create SQLite database with given name.</p> <p>Parameters:</p> Name Type Description Default <code>db_name</code> <code>str | Path</code> <p>Path or name of the SQLite database file</p> required <p>Yields:</p> Type Description <p>sqlite3.Connection: Database connection object</p> Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>@contextmanager\ndef open_sqlite_db(db_name: str | Path):\n    \"\"\"Open or create SQLite database with given name.\n\n    Args:\n        db_name: Path or name of the SQLite database file\n\n    Yields:\n        sqlite3.Connection: Database connection object\n    \"\"\"\n    logger.info(f\"Opening database {db_name}\")\n    conn = sqlite3.connect(db_name)\n    try:\n        yield conn\n    finally:\n        conn.close()\n</code></pre>"},{"location":"reference/state/#lythonic.state.execute_sql","title":"<code>execute_sql(cursor, sql, *args)</code>","text":"Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>def execute_sql(cursor: sqlite3.Cursor, sql: str, *args: Any):\n    logger.debug(f\"execute: {sql}\" + (f\" -- with args: {args}\" if len(args) &gt; 0 else \"\"))\n    cursor.execute(sql, *args)\n</code></pre>"},{"location":"reference/state/#lythonic.state.from_multi_model_row","title":"<code>from_multi_model_row(row, models)</code>","text":"Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>def from_multi_model_row(\n    row: tuple[Any, ...], models: list[type[DbModel[Any]]]\n) -&gt; Generator[DbModel[Any], None, None]:\n    start = 0\n    for model in models:\n        fields = list(model.get_field_infos())\n        yield model._from_row(row[start : start + len(fields)], fields)  # pyright: ignore [reportPrivateUsage]\n        start += len(fields)\n</code></pre>"},{"location":"reference/state/#lythonic.state.to_sql_datetime","title":"<code>to_sql_datetime(dt)</code>","text":"Source code in <code>src/lythonic/state/__init__.py</code> <pre><code>def to_sql_datetime(dt: datetime) -&gt; str:\n    return dt.isoformat()\n</code></pre>"},{"location":"reference/types/","title":"lythonic.types","text":"<p>Type mapping and conversion utilities.</p> <p>Types: Type mapping system for converting between Python, JSON, and SQLite types.</p> <p>This module provides a registry of known types and their conversion functions for seamless data transformation between different representations.</p>"},{"location":"reference/types/#lythonic.types--core-concepts","title":"Core Concepts","text":"<ul> <li><code>KnownType</code>: A registered type with bidirectional mappings (string, JSON, DB)</li> <li><code>KnownTypesMap</code>: Registry of all known types, accessed via <code>KNOWN_TYPES</code></li> <li><code>JsonBase</code>: Pydantic BaseModel with type discrimination via <code>type_gref</code></li> </ul>"},{"location":"reference/types/#lythonic.types--type-mappings","title":"Type Mappings","text":"<p>Each <code>KnownType</code> provides three <code>MapPair</code>s for converting to/from: - string: For CLI arguments, environment variables, config files - json: For JSON serialization (API responses, storage) - db: For SQLite storage (maps to INTEGER, REAL, TEXT, or BLOB)</p>"},{"location":"reference/types/#lythonic.types--built-in-types","title":"Built-in Types","text":"<p>Primitives: <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>bytes</code> Dates: <code>date</code>, <code>datetime</code> (ISO format strings) Enums: <code>Enum</code> (string values), <code>IntEnum</code> (integer values) Pydantic: <code>BaseModel</code>, <code>JsonBase</code> (JSON dicts) Paths: <code>Path</code> (string representation)</p>"},{"location":"reference/types/#lythonic.types--usage","title":"Usage","text":"<pre><code>from lythonic.types import KNOWN_TYPES, KnownType\n\n# Resolve a type\nkt = KNOWN_TYPES.resolve_type(datetime)\n\n# Convert from string\ndt = kt.string.map_from(\"2024-01-15T10:30:00\")\n\n# Convert to JSON\njson_val = kt.json.map_to(dt)  # \"2024-01-15T10:30:00\"\n\n# Convert to DB\ndb_val = kt.db.map_to(dt)  # \"2024-01-15T10:30:00\"\n</code></pre>"},{"location":"reference/types/#lythonic.types--registering-custom-types","title":"Registering Custom Types","text":"<pre><code>from lythonic.types import KNOWN_TYPES, KnownTypeArgs\n\nKNOWN_TYPES.register(\n    KnownTypeArgs(\n        concrete_type=MyType,\n        map_from_string=MyType.parse,\n        map_to_string=str,\n    )\n)\n</code></pre>"},{"location":"reference/types/#lythonic.types--jsonbase","title":"JsonBase","text":"<p><code>JsonBase</code> extends Pydantic's <code>BaseModel</code> with automatic type discrimination:</p> <pre><code>from lythonic.types import JsonBase\n\nclass Dog(JsonBase):\n    name: str\n\nclass Cat(JsonBase):\n    name: str\n\n# Serialize includes type reference\ndog = Dog(name=\"Rex\")\ndata = dog.to_json()  # {\"type_gref\": \"mymodule:Dog\", \"name\": \"Rex\"}\n\n# Deserialize resolves correct type\nanimal = JsonBase.from_json(data)  # Returns Dog instance\n</code></pre>"},{"location":"reference/types/#lythonic.types.KnownType","title":"<code>KnownType</code>","text":"Source code in <code>src/lythonic/types.py</code> <pre><code>class KnownType:\n    name: str\n    aliases: set[str]\n    type_: type\n    is_abstract: bool\n    string: MapPair[str]\n    json: MapPair[Any]\n    db: MapPair[Any]\n\n    @classmethod\n    def ensure(cls, type_: type | str | KnownType) -&gt; KnownType:\n        if isinstance(type_, KnownType):\n            return type_\n        return KNOWN_TYPES.resolve_type(type_)\n\n    def __init__(\n        self,\n        args: KnownTypeArgs,\n    ) -&gt; None:\n        assert not args.is_factory, \"factory types cannot be initialized directly\"\n        self.type_ = args.get_type()\n        self.is_abstract = args.is_abstract()\n        args.resolve_the_rest()\n        assert (\n            args.db_type is not None\n            and args.map_from_db is not None\n            and args.map_to_db is not None\n            and args.json_type is not None\n            and args.map_from_json is not None\n            and args.map_to_json is not None\n            and args.map_from_string is not None\n            and args.map_to_string is not None\n        ), f\"{self.type_} has not been resolved\"\n\n        self.string = MapPair(args.map_from_string, args.map_to_string, str)  # pyright: ignore\n        self.json = MapPair(args.map_from_json, args.map_to_json, args.json_type)\n        self.db = MapPair(args.map_from_db, args.map_to_db, args.db_type)\n        self.name = (args.name if args.name is not None else self.type_.__name__).lower()\n        self.aliases = set()\n        self.aliases.add(self.name)\n        if args.aliases is not None:\n            for alias in args.aliases:\n                self.aliases.add(alias.lower())\n\n    def get_type(self) -&gt; type:\n        return self.type_\n\n    @property\n    def db_type_info(self) -&gt; DbTypeInfo:\n        return DbTypeInfo.from_type(self.db.target_type)\n\n    @override\n    def __repr__(self) -&gt; str:\n        return f\"KnownType({self.name!r}, {self.type_!r})\"\n</code></pre>"},{"location":"reference/types/#lythonic.types.KnownTypeArgs","title":"<code>KnownTypeArgs</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/lythonic/types.py</code> <pre><code>class KnownTypeArgs(BaseModel):\n    map_from_string: Callable[[str], Any] | None = None\n    map_to_string: Callable[[Any], str] | None = None\n    map_from_json: Callable[[Any], Any] | None = None\n    map_to_json: Callable[[Any], Any] | None = None\n    map_from_db: Callable[[Any], Any] | None = None\n    map_to_db: Callable[[Any], Any] | None = None\n    db_type: type | None = None\n    json_type: type | None = None\n    concrete_type: type | None = None\n    abstract_type: type | None = None\n    is_factory: bool = False\n    name: str | None = None\n    aliases: list[str] | None = None\n\n    def get_type(self) -&gt; type:\n        assert self.abstract_type is not None or self.concrete_type is not None\n        if self.concrete_type is not None:\n            assert self.abstract_type is None and not self.is_factory, (\n                \"concrete types cannot be factories\"\n            )\n            return self.concrete_type\n        assert self.abstract_type is not None, \" Redundant but no other way to shut up pyright\"\n        return self.abstract_type\n\n    def is_abstract(self) -&gt; bool:\n        return self.abstract_type is self.get_type()\n\n    def build_concrete_type(self, concrete_type: type) -&gt; Self:\n        assert self.is_factory, \"only factory types can build concrete types\"\n        super_type = self.get_type()\n        assert issubclass(concrete_type, super_type), (\n            f\"concrete type {concrete_type} is not a subclass of abstract type {super_type}\"\n        )\n        clone = self.model_copy()\n        clone.concrete_type = concrete_type\n        clone.abstract_type = None\n        clone.is_factory = False\n\n        def remap_constructor_from_super_type_to_concrete_type(\n            x: Callable[[Any], Any] | None,\n        ) -&gt; Callable[[Any], Any] | None:\n            if x is None:\n                return None\n            if x is super_type:  # switch to constructor of concrete type\n                return concrete_type\n            if (\n                inspect.ismethod(x) and x.__self__ is super_type\n            ):  # switch to class  method of concrete type\n                return getattr(concrete_type, x.__name__)\n            return x  # leave as is\n\n        clone.map_from_string = remap_constructor_from_super_type_to_concrete_type(\n            clone.map_from_string\n        )\n        clone.map_from_json = remap_constructor_from_super_type_to_concrete_type(\n            clone.map_from_json\n        )\n        clone.map_from_db = remap_constructor_from_super_type_to_concrete_type(clone.map_from_db)\n        return clone\n\n    def _set_string_defaults(self) -&gt; None:\n        if self.db_type is None:\n            self.db_type = str\n        if self.json_type is None:\n            self.json_type = str\n        self.map_from_string = passthru_none(self.get_type(), if_none=self.map_from_string)\n        self.map_to_string = passthru_none(str, if_none=self.map_to_string)\n        self.map_from_json = passthru_none(self.map_from_string, if_none=self.map_from_json)\n        self.map_to_json = passthru_none(self.map_to_string, if_none=self.map_to_json)\n        self.map_from_db = passthru_none(self.map_from_string, if_none=self.map_from_db)\n        self.map_to_db = passthru_none(self.map_to_string, if_none=self.map_to_db)\n\n    def _set_db_defaults(self) -&gt; None:\n        assert self.db_type is not None and self.map_from_db is not None\n        self.map_to_db = passthru_none(self.db_type, if_none=self.map_to_db)\n        if self.db_type is bytes:\n            if self.json_type is None:\n                self.json_type = str\n            self.map_from_json = passthru_none(ensure_bytes, if_none=self.map_from_json)\n            self.map_to_json = passthru_none(encode_base64, if_none=self.map_to_json)\n            self.map_from_string = passthru_none(\n                ensure_bytes, self.map_from_db, if_none=self.map_from_string\n            )\n            self.map_to_string = passthru_none(\n                self.map_to_db, encode_base64, if_none=self.map_to_string\n            )\n        else:\n            if self.json_type is None:\n                self.json_type = self.db_type\n            self.map_from_json = passthru_none(self.map_from_db, if_none=self.map_from_json)\n            self.map_to_json = passthru_none(self.map_to_db, if_none=self.map_to_json)\n            self.map_from_string = passthru_none(\n                self.db_type, self.map_from_db, if_none=self.map_from_string\n            )\n            self.map_to_string = passthru_none(self.map_to_db, str, if_none=self.map_to_string)\n\n    def _set_json_defaults(self) -&gt; bool:\n        if self.map_from_json is not None and self.map_to_json is not None:\n            if self.db_type is None:\n                self.db_type = str\n            if self.json_type is None:\n                self.json_type = dict\n            self.map_from_json = passthru_none(self.map_from_json)\n            self.map_to_json = passthru_none(self.map_to_json)\n            self.map_from_string = passthru_none(\n                json_loads, self.map_from_json, if_none=self.map_from_string\n            )\n            self.map_to_string = passthru_none(\n                self.map_to_json, json_dumps, if_none=self.map_to_string\n            )\n            self.map_from_db = passthru_none(self.map_from_string, if_none=self.map_from_db)\n            self.map_to_db = passthru_none(self.map_to_string, if_none=self.map_to_db)\n            return True\n        return False\n\n    def resolve_the_rest(self) -&gt; Self:\n        assert not self.is_factory, \"factory types cannot resolve the rest\"\n        if self.concrete_type is not None:\n            assert self.abstract_type is None\n            if self.map_from_string is not None or self.map_to_string is not None:\n                self._set_string_defaults()\n            else:\n                if self.db_type is None and DbTypeInfo.is_db_type(self.concrete_type):  # pyright: ignore\n                    self.db_type = self.concrete_type\n                if self.db_type is not None:\n                    self.map_from_db = passthru_none(\n                        self.db_type, self.concrete_type, if_none=self.map_from_db\n                    )\n                    self._set_db_defaults()\n                else:\n                    self._set_json_defaults()\n\n        else:\n            assert self.abstract_type is not None\n            assert (\n                self.map_from_string is not None\n                or self.map_from_json is not None\n                or self.map_from_db is not None\n            )\n            if self.map_from_string is not None:\n                self._set_string_defaults()\n            elif self._set_json_defaults():\n                pass\n            elif self.db_type is not None:\n                assert self.map_from_db is not None\n                self.map_from_db = passthru_none(self.map_from_db)\n                self._set_db_defaults()\n\n        return self\n</code></pre>"},{"location":"reference/types/#lythonic.types.JsonBase","title":"<code>JsonBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/lythonic/types.py</code> <pre><code>class JsonBase(BaseModel):\n    type_gref: GRef | None = None\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def set_gref(cls, data: dict[str, Any]) -&gt; dict[str, Any]:\n        data[\"type_gref\"] = str(GlobalRef(cls))\n        return data\n\n    @classmethod\n    def from_json(cls, json: dict[str, Any]) -&gt; Self:\n        if \"type_gref\" in json:\n            ref = GlobalRef(json[\"type_gref\"])\n            cls_from_ref = ref.get_instance()\n            if issubclass(cls_from_ref, cls):\n                return cls_from_ref.model_validate(json)\n        return cls.model_validate(json)\n\n    def to_json(self) -&gt; dict[str, Any]:\n        return base_model_to_json(self)\n</code></pre>"},{"location":"reference/types/#lythonic.types.DbTypeInfo","title":"<code>DbTypeInfo</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/lythonic/types.py</code> <pre><code>class DbTypeInfo(Enum):\n    def __init__(self, input_types: tuple[type, ...], target_type: type):\n        assert isinstance(input_types, tuple), f\"input_types must be tuple, not {type(input_types)}\"\n        cls = self.__class__\n        if not hasattr(cls, \"_value2member_map_\"):\n            cls._value2member_map_ = {}\n        member_map = cls._value2member_map_\n        for k in input_types:\n            assert k not in member_map, f\"Duplicate input type {k} in {self.name}\"\n            member_map[k] = self\n        self.input_types = input_types\n        self.target_type = target_type\n\n    INTEGER = ((int, bool), int)\n    REAL = ((float,), float)\n    TEXT = ((str,), str)\n    BLOB = ((bytes,), bytes)\n\n    @classmethod\n    def from_type(cls, t: type) -&gt; DbTypeInfo:\n        return cast(\n            DbTypeInfo,\n            cls._value2member_map_[t],\n        )\n\n    @classmethod\n    def is_db_type(cls, type_: type) -&gt; bool:\n        \"\"\"could be used in db as it is\"\"\"\n        return type_ in cls._value2member_map_\n</code></pre>"},{"location":"reference/types/#lythonic.types.DbTypeInfo.is_db_type","title":"<code>is_db_type(type_)</code>  <code>classmethod</code>","text":"<p>could be used in db as it is</p> Source code in <code>src/lythonic/types.py</code> <pre><code>@classmethod\ndef is_db_type(cls, type_: type) -&gt; bool:\n    \"\"\"could be used in db as it is\"\"\"\n    return type_ in cls._value2member_map_\n</code></pre>"},{"location":"reference/types/#lythonic.types.MapPair","title":"<code>MapPair</code>","text":"<p>               Bases: <code>Generic[T]</code></p> Source code in <code>src/lythonic/types.py</code> <pre><code>class MapPair(Generic[T]):\n    target_type: type\n    map_from: Callable[[T], Any]\n    map_to: Callable[[Any], T]\n\n    def __init__(\n        self, map_from: Callable[[T], Any], map_to: Callable[[Any], T], target_type: type\n    ) -&gt; None:\n        self.map_from = map_from\n        self.map_to = map_to\n        self.target_type = target_type\n</code></pre>"},{"location":"reference/user/","title":"lythonic.state.user","text":"<p>Multi-tenant support with user-scoped data access.</p> <p>User: Multi-tenant user ownership patterns for database models.</p> <p>This module provides base classes for building multi-tenant applications where records are owned by users and access is controlled accordingly.</p>"},{"location":"reference/user/#lythonic.state.user--core-classes","title":"Core Classes","text":"<ul> <li><code>User</code>: Base user model with <code>user_id</code>, <code>info</code>, and <code>created_at</code></li> <li><code>UserContext</code>: Context object passed to operations requiring user scope</li> <li><code>UserOwned</code>: Base class for models that belong to a user</li> </ul>"},{"location":"reference/user/#lythonic.state.user--usage","title":"Usage","text":"<pre><code>from lythonic.state.user import User, UserContext, UserOwned, UserInfo\nfrom pydantic import Field\n\nclass MyUserInfo(UserInfo):\n    name: str\n    email: str\n\nclass Document(UserOwned[\"Document\"]):\n    doc_id: int = Field(default=-1, description=\"(PK)\")\n    title: str\n\n# Create user context\nuser = User(user_id=1, info=MyUserInfo(name=\"Alice\", email=\"alice@example.com\"))\nctx = UserContext(user=user)\n\n# Save with user context (enforces ownership)\ndoc = Document(title=\"My Doc\")\ndoc.save_with_ctx(ctx, conn)\n\n# Load with user context (only returns user's records)\ndoc = Document.load_by_id_with_ctx(conn, ctx, doc_id=1)\n</code></pre> <p>The <code>UserOwned</code> class overrides <code>save()</code> and <code>load_by_id()</code> to require <code>UserContext</code>, ensuring all database operations are scoped to the current user.</p>"},{"location":"reference/user/#lythonic.state.user.User","title":"<code>User</code>","text":"<p>               Bases: <code>DbModel['User']</code></p> Source code in <code>src/lythonic/state/user.py</code> <pre><code>class User(DbModel[\"User\"]):\n    user_id: int = Field(default=-1, description=\"(PK) Unique identifier for the user\")\n    info: UserInfo = Field(description=\"User information object\")\n    created_at: datetime = Field(\n        default_factory=utc_now, description=\"Date and time when the user was created\"\n    )\n</code></pre>"},{"location":"reference/user/#lythonic.state.user.UserInfo","title":"<code>UserInfo</code>","text":"<p>               Bases: <code>JsonBase</code></p> Source code in <code>src/lythonic/state/user.py</code> <pre><code>class UserInfo(JsonBase):\n    pass\n</code></pre>"},{"location":"reference/user/#lythonic.state.user.UserContext","title":"<code>UserContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/lythonic/state/user.py</code> <pre><code>class UserContext(BaseModel):\n    user: User\n</code></pre>"},{"location":"reference/user/#lythonic.state.user.UserOwned","title":"<code>UserOwned</code>","text":"<p>               Bases: <code>DbModel[UO]</code></p> Source code in <code>src/lythonic/state/user.py</code> <pre><code>class UserOwned(DbModel[UO]):\n    user_id: int = Field(default=-1, description=\"(FK:User.user_id) Reference to the user\")\n\n    @override\n    def save(self, conn: sqlite3.Connection) -&gt; Self:\n        raise NotImplementedError(\"Use save_with_ctx instead\")\n\n    @override\n    @classmethod\n    def load_by_id(cls: type[UO], conn: sqlite3.Connection, id: int) -&gt; UO | None:\n        raise NotImplementedError(\"Use load_by_id_with_ctx instead\")\n\n    def save_with_ctx(self, ctx: UserContext, conn: sqlite3.Connection):\n        self.user_id = ctx.user.user_id\n        cls = self.__class__\n        pks = cls._choose_fields(lambda fi: fi.primary_key)\n        assert len(pks) == 1\n        pk = pks[0]\n        pk_val = getattr(self, pk.name)\n        if pk_val == -1:\n            self.insert(conn, auto_increment=True)\n            return\n        n_updated = self.update(conn, user_ctx=ctx, **{pk.name: pk_val})\n        if n_updated == 0:\n            raise ValueError(\n                \"Possible Access violation:\",\n                \" Record does not exist or belong other user then the one in context:\",\n                ctx.user.user_id,\n            )\n        else:\n            assert n_updated == 1\n\n    @override\n    @classmethod\n    def _prepare_where(cls, conn: sqlite3.Connection, **filters: Any) -&gt; DbModel._WhereBased:\n        assert \"user_ctx\" in filters, f\"user_ctx:{GlobalRef(UserContext)!s} is required\"\n        user_ctx = filters.pop(\"user_ctx\")\n        assert isinstance(user_ctx, UserContext), (\n            f\"user_ctx:{GlobalRef(UserContext)!s} must be a UserContext\"\n        )\n        filters[\"user_id\"] = user_ctx.user.user_id\n        return super()._prepare_where(conn, **filters)\n\n    @classmethod\n    def load_by_id_with_ctx(\n        cls: type[UO], conn: sqlite3.Connection, user_ctx: UserContext, id: int\n    ) -&gt; UO | None:\n        rr: list[UO] = cls.select(conn, user_ctx=user_ctx, **{cls._ensure_pk().name: id})\n        assert len(rr) &lt;= 1\n        return rr[0] if rr else None\n</code></pre>"},{"location":"tutorials/cashflow-example/","title":"Cashflow Tracking Example","text":"<p>This tutorial walks through the cashflow tracking example in <code>lythonic.examples.cashflow_tracking</code>, demonstrating a real-world multi-tenant application.</p>"},{"location":"tutorials/cashflow-example/#overview","title":"Overview","text":"<p>The cashflow tracking example models:</p> <ul> <li>Organizations and Accounts</li> <li>Scheduled recurring events (deposits, payments)</li> <li>Cash events and projections</li> <li>Multi-tenant data isolation via <code>UserOwned</code></li> </ul>"},{"location":"tutorials/cashflow-example/#schema-design","title":"Schema Design","text":"<pre><code>from typing import Literal\nfrom pydantic import Field\nfrom lythonic.state import Schema\nfrom lythonic.state.user import User, UserOwned\n\nAccountType = Literal[\"cash\", \"credit_card\"]\nEventType = Literal[\"deposit\", \"payment\", \"set_balance\"]\n\nclass Organization(UserOwned[\"Organization\"]):\n    org_id: int = Field(default=-1, description=\"(PK)\")\n    name: str\n    is_hidden: bool = False\n\nclass Account(UserOwned[\"Account\"]):\n    acc_id: int = Field(default=-1, description=\"(PK)\")\n    org_id: int = Field(description=\"(FK:Organization.org_id)\")\n    name: str\n    account_type: AccountType\n    start_date: date\n    end_date: date | None = None\n\nSCHEMA = Schema([User, Organization, Account, ...])\n</code></pre>"},{"location":"tutorials/cashflow-example/#multi-tenant-pattern","title":"Multi-Tenant Pattern","text":"<p>All entities extend <code>UserOwned</code> instead of <code>DbModel</code>:</p> <pre><code>class UserOwned(DbModel):\n    user_id: int = Field(description=\"(FK:User.user_id)\")\n</code></pre> <p>This automatically:</p> <ul> <li>Adds <code>user_id</code> foreign key to every table</li> <li>Requires <code>UserContext</code> for all operations</li> <li>Scopes queries to the current user</li> </ul>"},{"location":"tutorials/cashflow-example/#using-usercontext","title":"Using UserContext","text":"<pre><code>from lythonic.state.user import User, UserContext\n\n# Create or load a user\nuser = User(info=UserInfo())\nuser.save(conn)\n\n# Create context\nctx = UserContext(user=user)\n\n# All operations require context\norg = Organization(name=\"My Company\")\norg.save_with_ctx(ctx, conn)\n\n# Queries are automatically scoped\nmy_orgs = Organization.select(conn, user_ctx=ctx)\n</code></pre>"},{"location":"tutorials/cashflow-example/#scheduled-events","title":"Scheduled Events","text":"<p>The example includes versioned scheduled events for recurring transactions:</p> <pre><code>class ScheduledEvent(UserOwned[\"ScheduledEvent\"]):\n    sch_id: int = Field(default=-1, description=\"(PK)\")\n    acc_id: int = Field(description=\"(FK:Account.acc_id)\")\n    event_type: EventType\n    frequency: FrequencyType  # weekly, monthly, etc.\n    amount: float | None\n    is_active: bool = True\n    start_date: date\n    end_date: date | None = None\n</code></pre> <p>Versioning allows tracking changes over time while preserving history.</p>"},{"location":"tutorials/cashflow-example/#key-patterns","title":"Key Patterns","text":"<ol> <li>User isolation - All data is scoped to users via <code>UserOwned</code></li> <li>Referential integrity - Foreign keys maintain relationships</li> <li>Temporal modeling - Start/end dates for time-bounded entities</li> <li>Literal constraints - Type-safe enums for status fields</li> </ol> <p>See the full source in <code>src/lythonic/examples/cashflow_tracking/</code>.</p>"},{"location":"tutorials/crud-operations/","title":"CRUD Operations","text":"<p>This tutorial covers all database operations: Create, Read, Update, Delete.</p>"},{"location":"tutorials/crud-operations/#setup","title":"Setup","text":"<pre><code>from lythonic.state import DbModel, Schema, open_sqlite_db\nfrom pydantic import Field\n\nclass Task(DbModel[\"Task\"]):\n    task_id: int = Field(default=-1, description=\"(PK)\")\n    title: str\n    priority: int = 0\n    completed: bool = False\n\nSCHEMA = Schema([Task])\nSCHEMA.create_schema(\"tasks.db\")\n</code></pre>"},{"location":"tutorials/crud-operations/#create-insert","title":"Create (Insert)","text":""},{"location":"tutorials/crud-operations/#using-save","title":"Using save()","text":"<p>The <code>save()</code> method handles both insert and update:</p> <pre><code>with open_sqlite_db(\"tasks.db\") as conn:\n    task = Task(title=\"Write docs\", priority=1)\n    task.save(conn)  # Inserts, sets task_id\n    print(task.task_id)  # Now has a real ID\n\n    conn.commit()\n</code></pre>"},{"location":"tutorials/crud-operations/#using-insert","title":"Using insert()","text":"<p>For explicit insert with auto-increment:</p> <pre><code>task = Task(title=\"Review code\")\ntask.insert(conn, auto_increment=True)\n</code></pre>"},{"location":"tutorials/crud-operations/#read-select","title":"Read (Select)","text":""},{"location":"tutorials/crud-operations/#select-all","title":"Select All","text":"<pre><code>all_tasks = Task.select(conn)\n</code></pre>"},{"location":"tutorials/crud-operations/#filter-by-field-value","title":"Filter by Field Value","text":"<pre><code>high_priority = Task.select(conn, priority=1)\nincomplete = Task.select(conn, completed=False)\n</code></pre>"},{"location":"tutorials/crud-operations/#filter-with-operators","title":"Filter with Operators","text":"<p>Prefix field names with operator and double underscore:</p> <pre><code># Greater than\nurgent = Task.select(conn, gt__priority=5)\n\n# Less than or equal\nlow = Task.select(conn, lte__priority=2)\n\n# Not equal\nactive = Task.select(conn, ne__completed=True)\n</code></pre> <p>Available operators: <code>eq</code>, <code>ne</code>, <code>gt</code>, <code>lt</code>, <code>gte</code>, <code>lte</code></p>"},{"location":"tutorials/crud-operations/#in-clause","title":"IN Clause","text":"<p>Pass a list for IN queries:</p> <pre><code>specific = Task.select(conn, priority=[1, 2, 3])\n</code></pre>"},{"location":"tutorials/crud-operations/#load-by-id","title":"Load by ID","text":"<pre><code>task = Task.load_by_id(conn, 42)  # Returns None if not found\n</code></pre>"},{"location":"tutorials/crud-operations/#count-and-exists","title":"Count and Exists","text":"<pre><code>count = Task.select_count(conn, completed=False)\nexists = Task.exists(conn, title=\"Write docs\")\n</code></pre>"},{"location":"tutorials/crud-operations/#update","title":"Update","text":""},{"location":"tutorials/crud-operations/#using-save_1","title":"Using save()","text":"<p>Modify and save:</p> <pre><code>task = Task.load_by_id(conn, 1)\ntask.title = \"Updated title\"\ntask.save(conn)  # Updates existing row\n\nconn.commit()\n</code></pre>"},{"location":"tutorials/crud-operations/#using-update","title":"Using update()","text":"<p>For explicit update with filters:</p> <pre><code>task.priority = 10\nn_updated = task.update(conn, task_id=task.task_id)\n</code></pre>"},{"location":"tutorials/crud-operations/#delete","title":"Delete","text":"<p>Currently, delete operations should be done with raw SQL:</p> <pre><code>from lythonic.state import execute_sql\n\ncursor = conn.cursor()\nexecute_sql(cursor, \"DELETE FROM Task WHERE task_id = ?\", [task_id])\nconn.commit()\n</code></pre>"},{"location":"tutorials/crud-operations/#transactions","title":"Transactions","text":"<p>Always commit after modifications:</p> <pre><code>with open_sqlite_db(\"tasks.db\") as conn:\n    task1 = Task(title=\"Task 1\")\n    task1.save(conn)\n\n    task2 = Task(title=\"Task 2\")\n    task2.save(conn)\n\n    conn.commit()  # Both saved atomically\n</code></pre> <p>If an exception occurs before commit, changes are rolled back when the connection closes.</p>"},{"location":"tutorials/first-schema/","title":"Your First Schema","text":"<p>This tutorial covers schema definition in depth.</p>"},{"location":"tutorials/first-schema/#basic-model-structure","title":"Basic Model Structure","text":"<p>Every database model inherits from <code>DbModel</code>:</p> <pre><code>from pydantic import Field\nfrom lythonic.state import DbModel\n\nclass Product(DbModel[\"Product\"]):\n    product_id: int = Field(default=-1, description=\"(PK)\")\n    name: str\n    price: float\n    in_stock: bool = True\n</code></pre>"},{"location":"tutorials/first-schema/#primary-keys","title":"Primary Keys","text":"<p>Mark a field as primary key by adding <code>(PK)</code> at the start of the description:</p> <pre><code>user_id: int = Field(default=-1, description=\"(PK) Unique identifier\")\n</code></pre> <p>Use <code>default=-1</code> for auto-increment behavior. When you call <code>save()</code> on a model with <code>pk=-1</code>, it inserts a new row and updates the field with the generated ID.</p>"},{"location":"tutorials/first-schema/#foreign-keys","title":"Foreign Keys","text":"<p>Mark foreign keys with <code>(FK:Table.field)</code>:</p> <pre><code>class Order(DbModel[\"Order\"]):\n    order_id: int = Field(default=-1, description=\"(PK)\")\n    customer_id: int = Field(description=\"(FK:Customer.customer_id)\")\n    total: float\n</code></pre> <p>This generates a <code>REFERENCES</code> clause in the DDL.</p>"},{"location":"tutorials/first-schema/#nullable-fields","title":"Nullable Fields","text":"<p>Use the union type <code>| None</code>:</p> <pre><code>email: str | None = Field(default=None, description=\"Optional email\")\nnotes: str | None = None  # Also works without Field()\n</code></pre>"},{"location":"tutorials/first-schema/#enum-and-literal-constraints","title":"Enum and Literal Constraints","text":"<p>Use <code>Literal</code> for constrained string values:</p> <pre><code>from typing import Literal\n\nclass Order(DbModel[\"Order\"]):\n    order_id: int = Field(default=-1, description=\"(PK)\")\n    status: Literal[\"pending\", \"shipped\", \"delivered\"]\n</code></pre> <p>This generates a CHECK constraint:</p> <pre><code>status TEXT NOT NULL CHECK (status IN ('pending', 'shipped', 'delivered'))\n</code></pre>"},{"location":"tutorials/first-schema/#supported-types","title":"Supported Types","text":"Python Type SQLite Type Notes <code>int</code>, <code>bool</code> INTEGER bool stored as 0/1 <code>float</code> REAL <code>str</code> TEXT <code>bytes</code> BLOB <code>datetime</code> TEXT ISO format <code>date</code> TEXT ISO format <code>Path</code> TEXT String path <code>Enum</code> TEXT Enum value <code>BaseModel</code> TEXT JSON string"},{"location":"tutorials/first-schema/#creating-the-schema","title":"Creating the Schema","text":"<pre><code>from lythonic.state import Schema\n\nSCHEMA = Schema([Customer, Order, Product])\nSCHEMA.create_schema(Path(\"shop.db\"))\n</code></pre> <p>Tables are created in the order listed, so put referenced tables first.</p>"}]}